<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TouchSocketPro.Dmtp</name>
    </assembly>
    <members>
        <member name="T:TouchSocket.Dmtp.DmtpClientFactory`1">
            <summary>
            提供DMTP客户端工厂的抽象类，用于创建和管理DMTP客户端实例。
            </summary>
            <typeparam name="TClient">客户端类型，必须是IDmtpClient接口的实现。</typeparam>
        </member>
        <member name="M:TouchSocket.Dmtp.DmtpClientFactory`1.IsAlive(`0)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.DmtpClientFactory`1.GetClient(System.TimeSpan)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.DmtpClientFactory`1.GetClientIds">
            <summary>
            获取所有已创建客户端的Id。
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Dmtp.HttpDmtpClientFactory`1">
            <summary>
            适用于基于Http协议的Dmtp的连接工厂。
            </summary>
            <typeparam name="TClient"></typeparam>
        </member>
        <member name="M:TouchSocket.Dmtp.HttpDmtpClientFactory`1.#ctor">
            <summary>
            适用于基于Http协议的Dmtp的连接工厂。
            </summary>
        </member>
        <member name="T:TouchSocket.Dmtp.HttpDmtpClientFactory">
            <summary>
             适用于基于<see cref="T:TouchSocket.Dmtp.HttpDmtpClient"/>的DmtpRpc的连接工厂。
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.HttpDmtpClientFactory.CreateClient(TouchSocket.Core.TouchSocketConfig)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Dmtp.TcpDmtpClientFactory`1">
            <summary>
            适用于基于Tcp协议的Dmtp的连接工厂。
            </summary>
            <typeparam name="TClient"></typeparam>
        </member>
        <member name="M:TouchSocket.Dmtp.TcpDmtpClientFactory`1.#ctor">
            <summary>
            适用于基于Tcp协议的Dmtp的连接工厂。
            </summary>
        </member>
        <member name="T:TouchSocket.Dmtp.TcpDmtpClientFactory">
            <summary>
             适用于基于<see cref="T:TouchSocket.Dmtp.TcpDmtpClient"/>的DmtpRpc的连接工厂。
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.TcpDmtpClientFactory.CreateClient(TouchSocket.Core.TouchSocketConfig)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Dmtp.FileTransfer.TcpDmtpClientFactoryFileTransferExtension">
            <summary>
            TcpDmtpClientFactoryFileTransferExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.FileTransfer.TcpDmtpClientFactoryFileTransferExtension.PullFile``1(TouchSocket.Dmtp.DmtpClientFactory{``0},TouchSocket.Dmtp.FileTransfer.MultithreadingFileOperator)">
            <summary>
            多线程拉取文件。
            <para>
            注意
            <list type="number">
            <item>如果返回正确结果，则无需其他动作。</item>
            <item>如果返回其他结果，则当<see cref="P:TouchSocket.Dmtp.FileTransfer.FileOperator.ResourceInfo"/>不为空时，可能会尝试续传。</item>
            </list>
            </para>
            </summary>
            <param name="clientFactory"></param>
            <param name="fileOperator"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.FileTransfer.TcpDmtpClientFactoryFileTransferExtension.PullFileAsync``1(TouchSocket.Dmtp.DmtpClientFactory{``0},TouchSocket.Dmtp.FileTransfer.MultithreadingFileOperator)">
            <summary>
            多线程拉取文件。
            <para>
            注意
            <list type="number">
            <item>如果返回正确结果，则无需其他动作。</item>
            <item>如果返回其他结果，则当<see cref="P:TouchSocket.Dmtp.FileTransfer.FileOperator.ResourceInfo"/>不为空时，可能会尝试续传。</item>
            </list>
            </para>
            </summary>
            <param name="clientFactory"></param>
            <param name="fileOperator"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.FileTransfer.TcpDmtpClientFactoryFileTransferExtension.PushFile``1(TouchSocket.Dmtp.DmtpClientFactory{``0},TouchSocket.Dmtp.FileTransfer.MultithreadingFileOperator)">
            <summary>
            多线程推送文件。
            <para>
            注意
            <list type="number">
            <item>如果返回正确结果，则无需其他动作。</item>
            <item>如果返回其他结果，则当<see cref="P:TouchSocket.Dmtp.FileTransfer.FileOperator.ResourceInfo"/>不为空时，可能会尝试续传。</item>
            </list>
            </para>
            </summary>
            <param name="clientFactory"></param>
            <param name="fileOperator"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.FileTransfer.TcpDmtpClientFactoryFileTransferExtension.PushFileAsync``1(TouchSocket.Dmtp.DmtpClientFactory{``0},TouchSocket.Dmtp.FileTransfer.MultithreadingFileOperator)">
            <summary>
            多线程推送文件。
            <para>
            注意
            <list type="number">
            <item>如果返回正确结果，则无需其他动作。</item>
            <item>如果返回其他结果，则当<see cref="P:TouchSocket.Dmtp.FileTransfer.FileOperator.ResourceInfo"/>不为空时，可能会尝试续传。</item>
            </list>
            </para>
            </summary>
            <param name="clientFactory"></param>
            <param name="fileOperator"></param>
            <returns></returns>
        </member>
        <member name="F:TouchSocket.Dmtp.FileTransfer.TcpDmtpClientFactoryFileTransferExtension.FindTransferIdsProperty">
            <summary>
            查找多路传输的id集合。
            <para>参数：
            <list type="number">
            <item>主客户端</item>
            <item>目标主客户端Id</item>
            <item>目标传输客户端Id集合，当没查到任何元素时，应当返回空数组。</item>
            </list>
            </para>
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.FileTransfer.TcpDmtpClientFactoryFileTransferExtension.PullFile``1(TouchSocket.Dmtp.DmtpClientFactory{``0},System.String,TouchSocket.Dmtp.FileTransfer.MultithreadingFileOperator)">
            <summary>
            多线程从指定客户端拉取文件。
            <para>
            注意
            <list type="number">
            <item>使用该功能时，请确保已实现<see cref="M:TouchSocket.Dmtp.FileTransfer.TcpDmtpClientFactoryFileTransferExtension.SetFindTransferIds``1(TouchSocket.Dmtp.DmtpClientFactory{``0},System.Func{System.String,System.String[]})"/>。</item>
            <item>如果返回正确结果，则无需其他动作。</item>
            <item>如果返回其他结果，则当<see cref="P:TouchSocket.Dmtp.FileTransfer.FileOperator.ResourceInfo"/>不为空时，可能会尝试续传。</item>
            </list>
            </para>
            </summary>
            <param name="clientFactory"></param>
            <param name="targetId"></param>
            <param name="fileOperator"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.FileTransfer.TcpDmtpClientFactoryFileTransferExtension.PullFileAsync``1(TouchSocket.Dmtp.DmtpClientFactory{``0},System.String,TouchSocket.Dmtp.FileTransfer.MultithreadingFileOperator)">
            <summary>
            多线程从指定客户端拉取文件。
            <para>
            注意
            <list type="number">
            <item>使用该功能时，请确保已实现<see cref="M:TouchSocket.Dmtp.FileTransfer.TcpDmtpClientFactoryFileTransferExtension.SetFindTransferIds``1(TouchSocket.Dmtp.DmtpClientFactory{``0},System.Func{System.String,System.String[]})"/>。</item>
            <item>如果返回正确结果，则无需其他动作。</item>
            <item>如果返回其他结果，则当<see cref="P:TouchSocket.Dmtp.FileTransfer.FileOperator.ResourceInfo"/>不为空时，可能会尝试续传。</item>
            </list>
            </para>
            </summary>
            <param name="clientFactory"></param>
            <param name="targetId"></param>
            <param name="fileOperator"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.FileTransfer.TcpDmtpClientFactoryFileTransferExtension.PushFile``1(TouchSocket.Dmtp.DmtpClientFactory{``0},System.String,TouchSocket.Dmtp.FileTransfer.MultithreadingFileOperator)">
            <summary>
            多线程推送文件。
            <para>
            注意
            <list type="number">
            <item>使用该功能时，请确保已实现<see cref="M:TouchSocket.Dmtp.FileTransfer.TcpDmtpClientFactoryFileTransferExtension.SetFindTransferIds``1(TouchSocket.Dmtp.DmtpClientFactory{``0},System.Func{System.String,System.String[]})"/>。</item>
            <item>如果返回正确结果，则无需其他动作。</item>
            <item>如果返回其他结果，则当<see cref="P:TouchSocket.Dmtp.FileTransfer.FileOperator.ResourceInfo"/>不为空时，可能会尝试续传。</item>
            </list>
            </para>
            </summary>
            <param name="clientFactory"></param>
            <param name="targetId"></param>
            <param name="fileOperator"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.FileTransfer.TcpDmtpClientFactoryFileTransferExtension.PushFileAsync``1(TouchSocket.Dmtp.DmtpClientFactory{``0},System.String,TouchSocket.Dmtp.FileTransfer.MultithreadingFileOperator)">
            <summary>
            多线程推送文件。
            <para>
            注意
            <list type="number">
            <item>使用该功能时，请确保已实现<see cref="M:TouchSocket.Dmtp.FileTransfer.TcpDmtpClientFactoryFileTransferExtension.SetFindTransferIds``1(TouchSocket.Dmtp.DmtpClientFactory{``0},System.Func{System.String,System.String[]})"/>。</item>
            <item>如果返回正确结果，则无需其他动作。</item>
            <item>如果返回其他结果，则当<see cref="P:TouchSocket.Dmtp.FileTransfer.FileOperator.ResourceInfo"/>不为空时，可能会尝试续传。</item>
            </list>
            </para>
            </summary>
            <param name="clientFactory"></param>
            <param name="targetId"></param>
            <param name="fileOperator"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.FileTransfer.TcpDmtpClientFactoryFileTransferExtension.SetFindTransferIds``1(TouchSocket.Dmtp.DmtpClientFactory{``0},System.Func{System.String,System.String[]})">
            <summary>
            查找多路传输的id集合。
            <para>参数：
            <list type="number">
            <item>主客户端</item>
            <item>目标主客户端Id</item>
            <item>目标传输客户端Id集合，当没查到任何元素时，应当返回空数组。</item>
            </list>
            </para>
            </summary>
            <param name="clientFactory"></param>
            <param name="func"></param>
        </member>
        <member name="T:TouchSocket.Dmtp.FileTransfer.MultithreadingFileOperator">
            <summary>
            多线程文件传输操作器
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.FileTransfer.MultithreadingFileOperator.#ctor">
            <summary>
            多线程文件传输操作器
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.FileTransfer.MultithreadingFileOperator.MultithreadingCount">
            <summary>
            最大多线程数量。默认10。
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.FileTransfer.MultithreadingFileOperator.AddFlowAsync(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.FileTransfer.MultithreadingFileOperator.SetLength(System.Int64)">
            <summary>
            设置流长度
            </summary>
            <param name="len"></param>
        </member>
        <member name="T:TouchSocket.Dmtp.Rpc.TcpDmtpClientFactoryRpcExtension">
            <summary>
            TcpDmtpClientFactoryRpcExtension
            </summary>
        </member>
        <member name="T:TouchSocket.Dmtp.Rpc.EventAccessException">
            <summary>
            事件访问异常
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.Rpc.EventAccessException.#ctor">
            <summary>
            初始化EventAccessException类的新实例
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.Rpc.EventAccessException.#ctor(System.String)">
            <summary>
            初始化EventAccessException类的新实例，并提供异常消息
            </summary>
            <param name="message">解释异常原因的字符串</param>
        </member>
        <member name="M:TouchSocket.Dmtp.Rpc.EventAccessException.#ctor(System.String,System.Exception)">
            <summary>
            初始化EventAccessException类的新实例，并提供异常消息和内部异常
            </summary>
            <param name="message">解释异常原因的字符串</param>
            <param name="inner">导致此异常的异常</param>
        </member>
        <member name="T:TouchSocket.Dmtp.Rpc.EventNameException">
            <summary>
            事件名称异常
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.Rpc.EventNameException.#ctor">
            <summary>
            初始化事件名称异常类的实例
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.Rpc.EventNameException.#ctor(System.String)">
            <summary>
            初始化事件名称异常类的实例，并带有一个说明异常的字符串
            </summary>
            <param name="message">解释异常原因的字符串</param>
        </member>
        <member name="M:TouchSocket.Dmtp.Rpc.EventNameException.#ctor(System.String,System.Exception)">
            <summary>
            初始化事件名称异常类的实例，并带有说明异常的字符串和一个内部异常
            </summary>
            <param name="message">解释异常原因的字符串</param>
            <param name="inner">导致当前异常的异常</param>
        </member>
        <member name="T:TouchSocket.Dmtp.Rpc.EventBus">
            <summary>
            事件总线
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.Rpc.EventBus.#ctor(System.String)">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.Rpc.EventBus.AddEvent(System.String,System.String,TouchSocket.Dmtp.Rpc.AccessType)">
            <summary>
            添加事件
            </summary>
            <param name="publisherId"></param>
            <param name="accessType"></param>
            <param name="eventName"></param>
            <exception cref="T:System.ArgumentNullException">参数为空</exception>
            <exception cref="T:TouchSocket.Dmtp.Rpc.EventNameException">事件已存在</exception>
        </member>
        <member name="M:TouchSocket.Dmtp.Rpc.EventBus.CanRaiseEvent(System.String,System.String,TouchSocket.Dmtp.Rpc.EventUnit@)">
            <summary>
            是否有权限触发事件。
            </summary>
            <param name="publisherId"></param>
            <param name="eventName"></param>
            <param name="eventUnit"></param>
        </member>
        <member name="M:TouchSocket.Dmtp.Rpc.EventBus.Clear">
            <summary>
            清除所有事件
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.Rpc.EventBus.ContainsEvent(System.String)">
            <summary>
            是否包含该事件
            </summary>
            <param name="eventName"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.Rpc.EventBus.GetEvents">
            <summary>
            获取所有事件名称
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.Rpc.EventBus.RemoveEvent(System.String,System.String)">
            <summary>
            移除事件
            </summary>
            <param name="publisherId"></param>
            <param name="eventName"></param>
            <exception cref="T:System.ArgumentNullException">参数为空</exception>
            <exception cref="T:TouchSocket.Dmtp.Rpc.EventNameException">事件名不存在</exception>
            <exception cref="T:TouchSocket.Dmtp.Rpc.EventAccessException">没有事件访问权限</exception>
        </member>
        <member name="M:TouchSocket.Dmtp.Rpc.EventBus.SubscribeEvent(System.String,System.String)">
            <summary>
            订阅事件
            </summary>
            <param name="eventName"></param>
            <param name="id"></param>
        </member>
        <member name="M:TouchSocket.Dmtp.Rpc.EventBus.UnsubscribeEvent(System.String,System.String)">
            <summary>
            移除订阅
            </summary>
            <param name="eventName"></param>
            <param name="id"></param>
        </member>
        <member name="T:TouchSocket.Dmtp.Rpc.AccessType">
            <summary>
            操作权限
            </summary>
        </member>
        <member name="F:TouchSocket.Dmtp.Rpc.AccessType.Owner">
            <summary>
            所有者可操作
            </summary>
        </member>
        <member name="F:TouchSocket.Dmtp.Rpc.AccessType.Service">
            <summary>
            服务器可操作
            </summary>
        </member>
        <member name="F:TouchSocket.Dmtp.Rpc.AccessType.Everyone">
            <summary>
            任何人可操作
            </summary>
        </member>
        <member name="T:TouchSocket.Dmtp.Rpc.RaiseSourceType">
            <summary>
            触发事件源类型
            </summary>
        </member>
        <member name="F:TouchSocket.Dmtp.Rpc.RaiseSourceType.Service">
            <summary>
            由服务器触发
            </summary>
        </member>
        <member name="F:TouchSocket.Dmtp.Rpc.RaiseSourceType.SessionClient">
            <summary>
            由服务器辅助类触发
            </summary>
        </member>
        <member name="F:TouchSocket.Dmtp.Rpc.RaiseSourceType.Client">
            <summary>
            由客户端触发
            </summary>
        </member>
        <member name="T:TouchSocket.Dmtp.Rpc.EventBusTriggers">
            <summary>
            事件触发器
            </summary>
        </member>
        <member name="T:TouchSocket.Dmtp.Rpc.EventContext">
            <summary>
            事件容器
            </summary>
        </member>
        <member name="T:TouchSocket.Dmtp.Rpc.EventRaiser">
            <summary>
            EventRaiser
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.Rpc.EventRaiser.#ctor(System.String,System.String,System.Byte[],TouchSocket.Dmtp.Rpc.EventSender)">
            <summary>
            初始化一个Event触发
            </summary>
            <param name="publisherId"></param>
            <param name="eventName"></param>
            <param name="data"></param>
            <param name="eventSender"></param>
        </member>
        <member name="P:TouchSocket.Dmtp.Rpc.EventRaiser.PublisherId">
            <summary>
            PublisherId
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.Rpc.EventRaiser.EventName">
            <summary>
            EventName
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.Rpc.EventRaiser.Data">
            <summary>
            Data
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.Rpc.EventRaiser.EventSender">
            <summary>
            EventSender
            </summary>
        </member>
        <member name="T:TouchSocket.Dmtp.Rpc.EventSender">
            <summary>
            事件参数触发
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.Rpc.EventSender.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.Rpc.EventSender.#ctor(System.String,TouchSocket.Dmtp.Rpc.RaiseSourceType,System.String)">
            <summary>
            构造函数
            </summary>
            <param name="eventName"></param>
            <param name="raiseSourceType"></param>
            <param name="iD"></param>
        </member>
        <member name="P:TouchSocket.Dmtp.Rpc.EventSender.RaiseSourceType">
            <summary>
            事件触发源类型
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.Rpc.EventSender.Id">
            <summary>
            当触发源为<see cref="F:TouchSocket.Dmtp.Rpc.RaiseSourceType.Client"/>或<see cref="F:TouchSocket.Dmtp.Rpc.RaiseSourceType.SessionClient"/>时，传递由哪个客户端触发。
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.Rpc.EventSender.EventName">
            <summary>
            事件名称
            </summary>
        </member>
        <member name="T:TouchSocket.Dmtp.Rpc.EventUnit">
            <summary>
            事件单元
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.Rpc.EventUnit.#ctor(TouchSocket.Dmtp.Rpc.AccessType)">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.Rpc.EventUnit.AccessType">
            <summary>
            操作权限
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.Rpc.EventUnit.EventName">
            <summary>
            事件名称
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.Rpc.EventUnit.PublisherId">
            <summary>
            发布者
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.Rpc.EventUnit.Subscribers">
            <summary>
            订阅者
            </summary>
        </member>
        <member name="T:TouchSocket.Dmtp.Rpc.IEventObject">
            <summary>
            事件对象
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.Rpc.IEventObject.RaiseEvent``1(System.String,``0)">
            <summary>
            触发事件
            </summary>
            <typeparam name="T"></typeparam>
            <param name="eventName"></param>
            <param name="arg"></param>
        </member>
        <member name="M:TouchSocket.Dmtp.Rpc.IEventObject.SubscribeEvent``1(System.String,System.Action{TouchSocket.Dmtp.Rpc.EventSender,``0})">
            <summary>
            订阅事件
            </summary>
            <param name="eventName"></param>
            <param name="action"></param>
        </member>
        <member name="M:TouchSocket.Dmtp.Rpc.IEventObject.UnsubscribeEvent(System.String)">
            <summary>
            取消订阅事件
            </summary>
            <param name="eventName"></param>
        </member>
        <member name="M:TouchSocket.Dmtp.Rpc.IEventObject.PublishEvent(System.String,TouchSocket.Dmtp.Rpc.AccessType)">
            <summary>
            发布事件
            </summary>
            <param name="eventName">事件名称</param>
            <param name="accessType">访问权限</param>
            <exception cref="T:System.ArgumentNullException">参数为空</exception>
            <exception cref="T:TouchSocket.Dmtp.Rpc.EventNameException">事件已存在</exception>
        </member>
        <member name="M:TouchSocket.Dmtp.Rpc.IEventObject.UnpublishEvent(System.String)">
            <summary>
            取消发布事件
            </summary>
            <param name="eventName"></param>
            <exception cref="T:System.ArgumentNullException">参数为空</exception>
        </member>
        <member name="M:TouchSocket.Dmtp.Rpc.IEventObject.GetAllEvents">
            <summary>
            获取所有事件名称
            </summary>
            <returns></returns>
        </member>
        <member name="P:TouchSocket.Dmtp.Rpc.IEventObject.Id">
            <summary>
            事件触发者Id
            </summary>
        </member>
        <member name="T:TouchSocket.Dmtp.Rpc.ITargetRpcActor">
            <summary>
            具有目标Id调用的Rpc
            </summary>
        </member>
        <member name="T:TouchSocket.Dmtp.Rpc.DeliverEventArgs">
            <summary>
            投递事件
            </summary>
        </member>
        <member name="T:TouchSocket.Dmtp.Rpc.MessageQueuePlugin">
            <summary>
            MessageQueuePlugin
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.Rpc.MessageQueuePlugin.Converter">
            <summary>
            定义元素的序列化和反序列化。
            <para>注意：Byte[]类型不用考虑。内部单独会做处理。</para>
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.Rpc.MessageQueuePlugin.SetConverter(TouchSocket.Core.BytesSerializerConverter)">
            <summary>
            定义元素的序列化和反序列化。
            <para>注意：Byte[]类型不用考虑。内部单独会做处理。</para>
            </summary>
            <param name="converter"></param>
        </member>
        <member name="T:TouchSocket.Dmtp.Rpc.DmtpResponseStream">
            <summary>
            ResponseStream
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.Rpc.DmtpResponseStream.#ctor(System.IO.Stream,TouchSocket.Core.IDataCompressor)">
            <summary>
            ResponseStream
            </summary>
            <param name="stream"></param>
            <param name="dataCompressor"></param>
        </member>
        <member name="P:TouchSocket.Dmtp.Rpc.DmtpResponseStream.Stream">
            <summary>
            实际的内部流
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.Rpc.DmtpResponseStream.DataCompressor">
            <summary>
            数据压缩机。
            </summary>
        </member>
        <member name="T:TouchSocket.Dmtp.INamedPipeDmtpClient">
            <summary>
            基于命名管道的Dmtp客户端接口
            </summary>
        </member>
        <member name="T:TouchSocket.Dmtp.INamedPipeDmtpService`1">
            <summary>
            INamedPipeDmtpService
            </summary>
        </member>
        <member name="T:TouchSocket.Dmtp.INamedPipeDmtpService">
            <summary>
            INamedPipeDmtpService
            </summary>
        </member>
        <member name="T:TouchSocket.Dmtp.INamedPipeDmtpServiceBase">
            <summary>
            INamedPipeDmtpServiceBase
            </summary>
        </member>
        <member name="T:TouchSocket.Dmtp.INamedPipeDmtpSessionClient">
            <summary>
            INamedPipeDmtpSessionClient
            </summary>
        </member>
        <member name="T:TouchSocket.Dmtp.NamedPipeDmtpClient">
            <summary>
            NamedPipeDmtpClient
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpClient.#ctor">
            <summary>
            NamedPipeDmtpClient
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.NamedPipeDmtpClient.DmtpActor">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Dmtp.NamedPipeDmtpClient.Id">
            <inheritdoc cref="P:TouchSocket.Sockets.IIdClient.Id"/>
        </member>
        <member name="P:TouchSocket.Dmtp.NamedPipeDmtpClient.Online">
            <inheritdoc cref="P:TouchSocket.Sockets.IOnlineClient.Online"/>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpClient.ConnectAsync(System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步使用NamedPipe进行Dmtp连接
            </summary>
            <param name="millisecondsTimeout"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpClient.ResetIdAsync(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpClient.LoadConfig(TouchSocket.Core.TouchSocketConfig)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpClient.OnNamedPipeReceived(TouchSocket.Sockets.ReceivedDataEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpClient.OnNamedPipeConnecting(TouchSocket.Sockets.ConnectingEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpClient.CloseAsync(System.String,System.Threading.CancellationToken)">
            <summary>
            发送<see cref="T:TouchSocket.Dmtp.IDmtpActor"/>关闭消息。
            </summary>
            <param name="msg"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpClient.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpClient.OnNamedPipeClosed(TouchSocket.Sockets.ClosedEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpClient.OnNamedPipeClosing(TouchSocket.Sockets.ClosingEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpClient.OnCreateChannel(TouchSocket.Dmtp.CreateChannelEventArgs)">
            <summary>
            当创建通道
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpClient.OnHandshaked(TouchSocket.Dmtp.DmtpVerifyEventArgs)">
            <summary>
            在完成握手连接时
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpClient.OnHandshaking(TouchSocket.Dmtp.DmtpVerifyEventArgs)">
            <summary>
            即将握手连接时
            </summary>
            <param name="e">参数</param>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpClient.OnRouting(TouchSocket.Dmtp.PackageRouterEventArgs)">
            <summary>
            当需要转发路由包时
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpClient.OnDmtpClosed(TouchSocket.Sockets.ClosedEventArgs)">
            <summary>
            当Dmtp关闭以后。
            </summary>
            <param name="e">事件参数</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpClient.OnDmtpClosing(TouchSocket.Sockets.ClosingEventArgs)">
            <summary>
            当Dmtp即将被关闭时触发。
            <para>
            该触发条件有2种：
            <list type="number">
            <item>终端主动调用<see cref="M:TouchSocket.Sockets.IClosableClient.CloseAsync(System.String,System.Threading.CancellationToken)"/>。</item>
            <item>终端收到<see cref="F:TouchSocket.Dmtp.DmtpActor.P0_Close"/>的请求。</item>
            </list>
            </para>
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Dmtp.NamedPipeDmtpService">
            <summary>
            NamedPipeDmtpService
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpService.NewClient">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Dmtp.NamedPipeDmtpService`1">
            <summary>
            NamedPipeDmtpService泛型类型
            </summary>
            <typeparam name="TClient"></typeparam>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpService`1.#ctor">
            <summary>
            NamedPipeDmtpService泛型类型
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.NamedPipeDmtpService`1.VerifyToken">
            <summary>
            连接令箭
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpService`1.LoadConfig(TouchSocket.Core.TouchSocketConfig)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpService`1.ClientInitialized(`0)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Dmtp.NamedPipeDmtpSessionClient">
            <summary>
             NamedPipeDmtpSessionClient
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpSessionClient.#ctor">
            <summary>
             NamedPipeDmtpSessionClient
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.NamedPipeDmtpSessionClient.DmtpActor">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Dmtp.NamedPipeDmtpSessionClient.Online">
            <inheritdoc cref="P:TouchSocket.Sockets.IOnlineClient.Online"/>
        </member>
        <member name="P:TouchSocket.Dmtp.NamedPipeDmtpSessionClient.VerifyTimeout">
            <summary>
            验证超时时间,默认为3000ms
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.NamedPipeDmtpSessionClient.VerifyToken">
            <summary>
            连接令箭
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpSessionClient.OnCreateChannel(TouchSocket.Dmtp.CreateChannelEventArgs)">
            <summary>
            当创建通道
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpSessionClient.OnDmtpClosed(TouchSocket.Sockets.ClosedEventArgs)">
            <summary>
            当Dmtp关闭以后。
            </summary>
            <param name="e">事件参数</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpSessionClient.OnDmtpClosing(TouchSocket.Sockets.ClosingEventArgs)">
            <summary>
            当Dmtp即将被关闭时触发。
            <para>
            该触发条件有2种：
            <list type="number">
            <item>终端主动调用<see cref="M:TouchSocket.Sockets.IClosableClient.CloseAsync(System.String,System.Threading.CancellationToken)"/>。</item>
            <item>终端收到<see cref="F:TouchSocket.Dmtp.DmtpActor.P0_Close"/>的请求。</item>
            </list>
            </para>
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpSessionClient.OnHandshaked(TouchSocket.Dmtp.DmtpVerifyEventArgs)">
            <summary>
            在完成握手连接时
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpSessionClient.OnHandshaking(TouchSocket.Dmtp.DmtpVerifyEventArgs)">
            <summary>
            在验证Token时
            </summary>
            <param name="e">参数</param>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpSessionClient.OnRouting(TouchSocket.Dmtp.PackageRouterEventArgs)">
            <summary>
            在需要转发路由包时。
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpSessionClient.CloseAsync(System.String,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpSessionClient.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpSessionClient.OnNamedPipeClosed(TouchSocket.Sockets.ClosedEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpSessionClient.OnNamedPipeClosing(TouchSocket.Sockets.ClosingEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpSessionClient.ResetIdAsync(System.String)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpSessionClient.OnNamedPipeConnected(TouchSocket.Sockets.ConnectedEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpSessionClient.OnNamedPipeConnecting(TouchSocket.Sockets.ConnectingEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.NamedPipeDmtpSessionClient.OnNamedPipeReceived(TouchSocket.Sockets.ReceivedDataEventArgs)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Dmtp.RemoteAccess.DmtpRemoteAccessActor">
            <summary>
            能够基于Dmtp协议，提供文件系统的基本访问功能。
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.DmtpRemoteAccessActor.#ctor(TouchSocket.Dmtp.IDmtpActor)">
            <summary>
            创建一个DmtpRemoteAccessActor
            </summary>
            <param name="dmtpActor"></param>
        </member>
        <member name="F:TouchSocket.Dmtp.RemoteAccess.DmtpRemoteAccessActor.RemoteAccessRouteType">
            <summary>
            定义一个名为RemoteAccess的路由类型，用于标识远程访问的路由。
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.DmtpRemoteAccessActor.SetProtocolFlags(System.UInt16)">
            <summary>
            设置处理协议标识的起始标识。
            </summary>
            <param name="start"></param>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteAccess.DmtpRemoteAccessActor.DmtpActor">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteAccess.DmtpRemoteAccessActor.OnRemoteAccessingAsync">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteAccess.DmtpRemoteAccessActor.OnRemoteAccessedAsync">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.DmtpRemoteAccessActor.InputReceivedData(TouchSocket.Dmtp.DmtpMessage)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.DmtpRemoteAccessActor.RemoteAccessAsync(TouchSocket.Dmtp.RemoteAccess.RemoteAccessOption)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Dmtp.RemoteAccess.IDmtpRemoteAccessActor">
            <summary>
            能够基于Dmtp协议，提供文件系统的基本访问功能。
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.IDmtpRemoteAccessActor.RemoteAccessAsync(TouchSocket.Dmtp.RemoteAccess.RemoteAccessOption)">
            <summary>
            远程访问
            </summary>
            <param name="option"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Dmtp.RemoteAccess.DmtpRemoteAccessExtension">
            <summary>
            DmtpRemoteAccessExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.DmtpRemoteAccessExtension.GetRemoteAccessActor(TouchSocket.Dmtp.IDmtpActor)">
            <summary>
            从DmtpActor中获取DmtpRpcActor
            </summary>
            <param name="dmtpActor"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.DmtpRemoteAccessExtension.UseDmtpRemoteAccess(TouchSocket.Core.IPluginManager)">
            <summary>
            使用RemoteAccess插件
            </summary>
            <param name="pluginManager"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.DmtpRemoteAccessExtension.GetRemoteAccessActor(TouchSocket.Dmtp.IDmtpActorObject)">
            <summary>
            获取远程访问的<see cref="T:TouchSocket.Dmtp.RemoteAccess.IDmtpRemoteAccessActor"/>
            </summary>
            <param name="client"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.DmtpRemoteAccessExtension.CreateDirectoryAsync``1(``0,System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步创建远程端的文件夹
            </summary>
            <typeparam name="TRpcActor"></typeparam>
            <param name="rpcActor"></param>
            <param name="path"></param>
            <param name="metadata"></param>
            <param name="millisecondsTimeout"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.DmtpRemoteAccessExtension.DeleteDirectoryAsync``1(``0,System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步删除远程端的文件夹
            </summary>
            <typeparam name="TRpcActor"></typeparam>
            <param name="rpcActor"></param>
            <param name="path"></param>
            <param name="metadata"></param>
            <param name="millisecondsTimeout"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.DmtpRemoteAccessExtension.DeleteFileAsync``1(``0,System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步删除远程端的文件
            </summary>
            <typeparam name="TRpcActor"></typeparam>
            <param name="rpcActor"></param>
            <param name="path"></param>
            <param name="metadata"></param>
            <param name="millisecondsTimeout"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.DmtpRemoteAccessExtension.DirectoryCopyAsync``1(``0,System.String,System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步复制远程端的文件夹到指定目录
            </summary>
            <typeparam name="TRpcActor"></typeparam>
            <param name="rpcActor"></param>
            <param name="path"></param>
            <param name="targetPath"></param>
            <param name="metadata"></param>
            <param name="millisecondsTimeout"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.DmtpRemoteAccessExtension.DirectoryMoveAsync``1(``0,System.String,System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步移动远程端的文件夹到指定目录
            </summary>
            <typeparam name="TRpcActor"></typeparam>
            <param name="rpcActor"></param>
            <param name="path"></param>
            <param name="targetPath"></param>
            <param name="metadata"></param>
            <param name="millisecondsTimeout"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.DmtpRemoteAccessExtension.FileCopyAsync``1(``0,System.String,System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步复制远程端的文件到指定目录
            </summary>
            <typeparam name="TRpcActor"></typeparam>
            <param name="rpcActor"></param>
            <param name="path"></param>
            <param name="targetPath"></param>
            <param name="metadata"></param>
            <param name="millisecondsTimeout"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.DmtpRemoteAccessExtension.FileMoveAsync``1(``0,System.String,System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步移动远程端的文件到指定目录
            </summary>
            <typeparam name="TRpcActor"></typeparam>
            <param name="rpcActor"></param>
            <param name="path"></param>
            <param name="targetPath"></param>
            <param name="metadata"></param>
            <param name="millisecondsTimeout"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.DmtpRemoteAccessExtension.GetDirectoryInfoAsync``1(``0,System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步获取远程端的文件夹信息
            </summary>
            <typeparam name="TRpcActor"></typeparam>
            <param name="rpcActor"></param>
            <param name="path"></param>
            <param name="metadata"></param>
            <param name="millisecondsTimeout"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.DmtpRemoteAccessExtension.GetFileInfoAsync``1(``0,System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步获取远程端的文件信息
            </summary>
            <typeparam name="TRpcActor"></typeparam>
            <param name="rpcActor"></param>
            <param name="path"></param>
            <param name="metadata"></param>
            <param name="millisecondsTimeout"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Dmtp.RemoteAccess.RemoteAccessedEventArgs">
            <summary>
            RemoteAccessedEventArgs
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.RemoteAccessedEventArgs.#ctor(TouchSocket.Dmtp.RemoteAccess.RemoteAccessType,TouchSocket.Dmtp.RemoteAccess.RemoteAccessMode,TouchSocket.Core.Metadata,TouchSocket.Core.Result)">
            <summary>
            远程操作访问
            </summary>
            <param name="accessType"></param>
            <param name="accessMode"></param>
            <param name="metadata"></param>
            <param name="result"></param>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteAccess.RemoteAccessedEventArgs.Result">
            <summary>
            执行结果
            </summary>
        </member>
        <member name="T:TouchSocket.Dmtp.RemoteAccess.RemoteAccessEventArgs">
            <summary>
            RemoteAccessEventArgs
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteAccess.RemoteAccessEventArgs.AccessMode">
            <summary>
            访问模式
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteAccess.RemoteAccessEventArgs.AccessType">
            <summary>
            访问类型
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteAccess.RemoteAccessEventArgs.Metadata">
            <summary>
            元数据
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteAccess.RemoteAccessEventArgs.Path">
            <summary>
            访问路径。该值可以在正式执行前修改。
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteAccess.RemoteAccessEventArgs.TargetPath">
            <summary>
            目标路径，用于指示复制、移动的最终地址。
            </summary>
        </member>
        <member name="T:TouchSocket.Dmtp.RemoteAccess.RemoteAccessingEventArgs">
            <summary>
            RemoteAccessActionEventArgs
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.RemoteAccessingEventArgs.#ctor(TouchSocket.Dmtp.RemoteAccess.RemoteAccessType,TouchSocket.Dmtp.RemoteAccess.RemoteAccessMode,TouchSocket.Core.Metadata)">
            <summary>
            RemoteAccessActionEventArgs
            </summary>
            <param name="accessType"></param>
            <param name="accessMode"></param>
            <param name="metadata"></param>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteAccess.RemoteAccessingEventArgs.Executed">
            <summary>
            表示已经执行，则内部不再做任何事，直接会返回确认的标识。
            </summary>
        </member>
        <member name="T:TouchSocket.Dmtp.RemoteAccess.IDmtpRemoteAccessedPlugin">
            <summary>
            表示一个远程访问插件，继承自IPlugin接口
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.IDmtpRemoteAccessedPlugin.OnRemoteAccessed(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RemoteAccess.RemoteAccessedEventArgs)">
            <summary>
            在远程操作访问之后调用的方法。
            </summary>
            <param name="client">进行远程访问的客户端对象</param>
            <param name="e">包含远程访问相关信息的事件参数</param>
            <returns>一个异步任务，表示操作尚未完成</returns>
        </member>
        <member name="T:TouchSocket.Dmtp.RemoteAccess.IDmtpRemoteAccessingPlugin">
            <summary>
            表示一个远程访问插件的接口，用于在远程操作前执行特定操作。
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.IDmtpRemoteAccessingPlugin.OnRemoteAccessing(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RemoteAccess.RemoteAccessingEventArgs)">
            <summary>
            在远程操作访问之前执行的操作。
            </summary>
            <param name="client">进行远程操作的客户端对象。</param>
            <param name="e">包含远程操作相关信息的事件参数。</param>
            <returns>一个任务，表示异步操作已完成。</returns>
        </member>
        <member name="T:TouchSocket.Dmtp.RemoteAccess.RemoteAccessType">
            <summary>
            访问类型
            </summary>
        </member>
        <member name="F:TouchSocket.Dmtp.RemoteAccess.RemoteAccessType.File">
            <summary>
            文件
            </summary>
        </member>
        <member name="F:TouchSocket.Dmtp.RemoteAccess.RemoteAccessType.Directory">
            <summary>
            文件目录
            </summary>
        </member>
        <member name="T:TouchSocket.Dmtp.RemoteAccess.RemoteAccessMode">
            <summary>
            访问模式
            </summary>
        </member>
        <member name="F:TouchSocket.Dmtp.RemoteAccess.RemoteAccessMode.Info">
            <summary>
            信息类
            </summary>
        </member>
        <member name="F:TouchSocket.Dmtp.RemoteAccess.RemoteAccessMode.Create">
            <summary>
            创建
            </summary>
        </member>
        <member name="F:TouchSocket.Dmtp.RemoteAccess.RemoteAccessMode.Delete">
            <summary>
            删除
            </summary>
        </member>
        <member name="F:TouchSocket.Dmtp.RemoteAccess.RemoteAccessMode.Copy">
            <summary>
            复制
            </summary>
        </member>
        <member name="F:TouchSocket.Dmtp.RemoteAccess.RemoteAccessMode.Move">
            <summary>
            移动
            </summary>
        </member>
        <member name="T:TouchSocket.Dmtp.RemoteAccess.RemoteAccessFeature">
            <summary>
            远程访问功能组件
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.RemoteAccessFeature.#ctor">
            <summary>
            RemoteAccessFeature
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteAccess.RemoteAccessFeature.ReserveProtocolSize">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteAccess.RemoteAccessFeature.StartProtocol">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.RemoteAccessFeature.OnDmtpHandshaking(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.DmtpVerifyEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.RemoteAccessFeature.OnDmtpReceived(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.DmtpMessageEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.RemoteAccessFeature.SetProtocolFlags(System.UInt16)">
            <summary>
            设置<see cref="T:TouchSocket.Dmtp.RemoteAccess.RemoteAccessFeature"/>的起始协议。
            <para>
            默认起始为：50，保留5个协议长度。
            </para>
            </summary>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.RemoteAccessFeature.Loaded(TouchSocket.Core.IPluginManager)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Dmtp.RemoteAccess.RemoteAccessOption">
            <summary>
            远程访问选项
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteAccess.RemoteAccessOption.AccessType">
            <summary>
            访问类型
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteAccess.RemoteAccessOption.AccessMode">
            <summary>
            访问模式
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteAccess.RemoteAccessOption.Path">
            <summary>
            访问路径
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteAccess.RemoteAccessOption.TargetPath">
            <summary>
            目标路径，用于指示复制、移动的最终地址。
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteAccess.RemoteAccessOption.Metadata">
            <summary>
            元数据
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteAccess.RemoteAccessOption.Timeout">
            <summary>
            超时时间(默认5000ms)
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteAccess.RemoteAccessOption.Token">
            <summary>
            可取消令箭
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.RemoteAccessOption.Package``1(``0@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.RemoteAccessOption.Unpackage``1(``0@)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Dmtp.RemoteAccess.RemoteAccessResult">
            <summary>
            访问结果
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.RemoteAccessResult.#ctor(TouchSocket.Dmtp.FileTransfer.RemoteFileInfo,TouchSocket.Dmtp.RemoteAccess.RemoteDirectoryInfo,TouchSocket.Core.Result)">
            <summary>
            访问结果
            </summary>
            <param name="fileInfo"></param>
            <param name="directoryInfo"></param>
            <param name="result"></param>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteAccess.RemoteAccessResult.FileInfo">
            <summary>
            FileInfo
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteAccess.RemoteAccessResult.DirectoryInfo">
            <summary>
            DirectoryInfo
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteAccess.RemoteAccessResult.Result">
            <summary>
            Result
            </summary>
        </member>
        <member name="T:TouchSocket.Dmtp.RemoteAccess.RemoteDirectoryInfo">
            <summary>
            远程文件夹信息
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteAccess.RemoteDirectoryInfo.Directories">
            <summary>
            当前目录包含的文件夹名称。不含路径。不含子文件夹。
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteAccess.RemoteDirectoryInfo.Files">
            <summary>
            当前目录包含的子文件名称。不含路径。
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.RemoteDirectoryInfo.Package``1(``0@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.RemoteDirectoryInfo.Unpackage``1(``0@)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Dmtp.RemoteAccess.RemoteDirectoryInfoResult">
            <summary>
            RemoteDirectoryInfoResult
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess.RemoteDirectoryInfoResult.#ctor(TouchSocket.Dmtp.RemoteAccess.RemoteDirectoryInfo,TouchSocket.Core.ResultCode,System.String)">
            <summary>
            RemoteDirectoryInfoResult
            </summary>
            <param name="directoryInfo"></param>
            <param name="resultCode"></param>
            <param name="message"></param>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteAccess.RemoteDirectoryInfoResult.DirectoryInfo">
            <summary>
            文件信息
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteAccess.RemoteDirectoryInfoResult.ResultCode">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteAccess.RemoteDirectoryInfoResult.Message">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteAccess.RemoteDirectoryInfoResult.IsSuccess">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Dmtp.RemoteAccess._DmtpRemoteAccessedPluginExtensions">
            <inheritdoc cref = "T:TouchSocket.Dmtp.RemoteAccess.IDmtpRemoteAccessedPlugin"/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess._DmtpRemoteAccessedPluginExtensions.AddDmtpRemoteAccessedPlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RemoteAccess.RemoteAccessedEventArgs,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Dmtp.RemoteAccess.IDmtpRemoteAccessedPlugin.OnRemoteAccessed(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RemoteAccess.RemoteAccessedEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess._DmtpRemoteAccessedPluginExtensions.AddDmtpRemoteAccessedPlugin(TouchSocket.Core.IPluginManager,System.Action{TouchSocket.Dmtp.IDmtpActorObject})">
            <inheritdoc cref = "M:TouchSocket.Dmtp.RemoteAccess.IDmtpRemoteAccessedPlugin.OnRemoteAccessed(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RemoteAccess.RemoteAccessedEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess._DmtpRemoteAccessedPluginExtensions.AddDmtpRemoteAccessedPlugin(TouchSocket.Core.IPluginManager,System.Action)">
            <inheritdoc cref = "M:TouchSocket.Dmtp.RemoteAccess.IDmtpRemoteAccessedPlugin.OnRemoteAccessed(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RemoteAccess.RemoteAccessedEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess._DmtpRemoteAccessedPluginExtensions.AddDmtpRemoteAccessedPlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Dmtp.RemoteAccess.RemoteAccessedEventArgs,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Dmtp.RemoteAccess.IDmtpRemoteAccessedPlugin.OnRemoteAccessed(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RemoteAccess.RemoteAccessedEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess._DmtpRemoteAccessedPluginExtensions.AddDmtpRemoteAccessedPlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Dmtp.IDmtpActorObject,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Dmtp.RemoteAccess.IDmtpRemoteAccessedPlugin.OnRemoteAccessed(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RemoteAccess.RemoteAccessedEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess._DmtpRemoteAccessedPluginExtensions.AddDmtpRemoteAccessedPlugin(TouchSocket.Core.IPluginManager,System.Func{System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Dmtp.RemoteAccess.IDmtpRemoteAccessedPlugin.OnRemoteAccessed(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RemoteAccess.RemoteAccessedEventArgs)"/>
        </member>
        <member name="T:TouchSocket.Dmtp.RemoteAccess._DmtpRemoteAccessingPluginExtensions">
            <inheritdoc cref = "T:TouchSocket.Dmtp.RemoteAccess.IDmtpRemoteAccessingPlugin"/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess._DmtpRemoteAccessingPluginExtensions.AddDmtpRemoteAccessingPlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RemoteAccess.RemoteAccessingEventArgs,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Dmtp.RemoteAccess.IDmtpRemoteAccessingPlugin.OnRemoteAccessing(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RemoteAccess.RemoteAccessingEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess._DmtpRemoteAccessingPluginExtensions.AddDmtpRemoteAccessingPlugin(TouchSocket.Core.IPluginManager,System.Action{TouchSocket.Dmtp.IDmtpActorObject})">
            <inheritdoc cref = "M:TouchSocket.Dmtp.RemoteAccess.IDmtpRemoteAccessingPlugin.OnRemoteAccessing(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RemoteAccess.RemoteAccessingEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess._DmtpRemoteAccessingPluginExtensions.AddDmtpRemoteAccessingPlugin(TouchSocket.Core.IPluginManager,System.Action)">
            <inheritdoc cref = "M:TouchSocket.Dmtp.RemoteAccess.IDmtpRemoteAccessingPlugin.OnRemoteAccessing(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RemoteAccess.RemoteAccessingEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess._DmtpRemoteAccessingPluginExtensions.AddDmtpRemoteAccessingPlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Dmtp.RemoteAccess.RemoteAccessingEventArgs,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Dmtp.RemoteAccess.IDmtpRemoteAccessingPlugin.OnRemoteAccessing(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RemoteAccess.RemoteAccessingEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess._DmtpRemoteAccessingPluginExtensions.AddDmtpRemoteAccessingPlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Dmtp.IDmtpActorObject,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Dmtp.RemoteAccess.IDmtpRemoteAccessingPlugin.OnRemoteAccessing(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RemoteAccess.RemoteAccessingEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteAccess._DmtpRemoteAccessingPluginExtensions.AddDmtpRemoteAccessingPlugin(TouchSocket.Core.IPluginManager,System.Func{System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Dmtp.RemoteAccess.IDmtpRemoteAccessingPlugin.OnRemoteAccessing(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RemoteAccess.RemoteAccessingEventArgs)"/>
        </member>
        <member name="T:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStreamActor">
            <summary>
            提供一个基于Dmtp协议的远程流数据映射功能。
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStreamActor.#ctor(TouchSocket.Dmtp.IDmtpActor,System.Collections.Concurrent.ConcurrentDictionary{System.Int32,TouchSocket.Dmtp.RemoteStream.LoadingStreamEventArgs})">
            <summary>
            提供一个基于Dmtp协议的远程流数据映射功能。
            </summary>
            <param name="dmtpActor"></param>
            <param name="remoteStreams"></param>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStreamActor.OnLoadingStreamAsync">
            <summary>
            OnLoadingStream
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStreamActor.DmtpActor">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStreamActor.TransferPackage">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStreamActor.InputReceivedData(TouchSocket.Dmtp.DmtpMessage)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStreamActor.LoadRemoteStream(TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <summary>
            装载远程流文件。
            </summary>
            <param name="metadata"></param>
            <param name="millisecondsTimeout"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStreamActor.LoadRemoteStream(System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <summary>
            装载远程流文件。
            </summary>
            <param name="targetId"></param>
            <param name="metadata"></param>
            <param name="millisecondsTimeout"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStreamActor.LoadRemoteStreamAsync(TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <summary>
            装载远程流文件。
            </summary>
            <param name="metadata"></param>
            <param name="millisecondsTimeout"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStreamActor.LoadRemoteStreamAsync(System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <summary>
            装载远程流文件。
            </summary>
            <param name="targetId"></param>
            <param name="metadata"></param>
            <param name="millisecondsTimeout"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStreamActor.SetProtocolFlags(System.UInt16)">
            <summary>
            设置处理协议标识的起始标识。
            </summary>
            <param name="start"></param>
        </member>
        <member name="T:TouchSocket.Dmtp.RemoteStream.IDmtpRemoteStreamActor">
            <summary>
            提供一个基于Dmtp协议的远程流数据映射接口。
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteStream.IDmtpRemoteStreamActor.LoadRemoteStreamAsync(TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <summary>
            加载一个远程流数据，映射在本地。
            </summary>
            <param name="metadata"></param>
            <param name="millisecondsTimeout"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteStream.IDmtpRemoteStreamActor.LoadRemoteStreamAsync(System.String,TouchSocket.Core.Metadata,System.Int32,System.Threading.CancellationToken)">
            <summary>
            加载一个指定Id的远程流数据，映射在本地。
            </summary>
            <param name="targetId"></param>
            <param name="metadata"></param>
            <param name="millisecondsTimeout"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStream">
            <summary>
            远程流访问
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStream.DataCompressor">
            <summary>
            数据压缩机。
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStream.Metadata">
            <summary>
            元数据
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStream.TryCount">
            <summary>
            重试次数，默认3。
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStream.Timeout">
            <summary>
            单次通信超时时长，默认10*1000毫秒。
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStream.SetLengthAsync(System.Int64)">
            <summary>
            异步设置当前对象的长度。
            </summary>
            <param name="value">期望设置的新长度。</param>
            <returns>一个异步任务，指示操作的完成。</returns>
            <remarks>
            此方法的具体实现由派生类提供。它应当处理长度设置的逻辑，
            并确保任何相关的资源或验证规则得到适当的应用。
            </remarks>
        </member>
        <member name="T:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStreamExtension">
            <summary>
            DmtpRemoteStreamExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStreamExtension.GetRemoteStreamActor(TouchSocket.Dmtp.IDmtpActor)">
            <summary>
            从<see cref="T:TouchSocket.Dmtp.IDmtpActor"/>中获取<see cref="T:TouchSocket.Dmtp.RemoteStream.IDmtpRemoteStreamActor"/>
            </summary>
            <param name="dmtpActor"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStreamExtension.UseDmtpRemoteStream(TouchSocket.Core.IPluginManager)">
            <summary>
            使用RemoteAccess功能
            </summary>
            <param name="pluginManager"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStreamExtension.GetDmtpRemoteStreamActor(TouchSocket.Dmtp.IDmtpActorObject)">
            <summary>
            从<see cref="T:TouchSocket.Dmtp.IDmtpActorObject"/>中获取<see cref="T:TouchSocket.Dmtp.RemoteStream.IDmtpRemoteStreamActor"/>
            </summary>
            <param name="client"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStreamFeature">
            <summary>
            提供远程流数据访问的插件功能。
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStreamFeature.StartProtocol">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStreamFeature.ReserveProtocolSize">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStreamFeature.#ctor">
            <summary>
            提供远程流数据访问的插件。
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStreamFeature.Loaded(TouchSocket.Core.IPluginManager)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStreamFeature.SetProtocolFlags(System.UInt16)">
            <summary>
            设置<see cref="T:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStreamFeature"/>的起始协议。
            <para>
            默认起始为：55，保留5个协议长度。
            </para>
            </summary>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStreamFeature.OnDmtpHandshaking(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.DmtpVerifyEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStreamFeature.OnDmtpReceived(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.DmtpMessageEventArgs)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStreamUtility">
            <summary>
            DmtpRemoteStreamUtility
            </summary>
        </member>
        <member name="F:TouchSocket.Dmtp.RemoteStream.DmtpRemoteStreamUtility.LoadRemoteStream">
            <summary>
            加载远程流数据
            </summary>
        </member>
        <member name="T:TouchSocket.Dmtp.RemoteStream.LoadingStreamEventArgs">
            <summary>
            LoadStreamEventArgs
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteStream.LoadingStreamEventArgs.DataCompressor">
            <summary>
            数据压缩机。
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteStream.LoadingStreamEventArgs.Metadata">
            <summary>
            元数据
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RemoteStream.LoadingStreamEventArgs.Stream">
            <summary>
            流对象
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteStream.LoadingStreamEventArgs.WaitingLoadStreamAsync(System.IO.Stream,System.TimeSpan)">
            <summary>
            载入一个需要映射到远程的流文件。
            </summary>
            <param name="stream"></param>
            <param name="timeSpan"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteStream.LoadingStreamEventArgs.WaitingLoadStreamAsync(System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            载入一个需要映射到远程的流文件。
            </summary>
            <param name="stream"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Dmtp.RemoteStream.IDmtpRemoteStreamPlugin">
            <summary>
            表示一个远程请求加载流的插件接口。
            该接口继承自IPlugin，用于扩展系统的远程流加载功能。
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteStream.IDmtpRemoteStreamPlugin.OnLoadingStream(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RemoteStream.LoadingStreamEventArgs)">
            <summary>
            在远程请求加载流时触发。
            </summary>
            <param name="client">发起请求的客户端对象。</param>
            <param name="e">包含加载流相关信息的事件参数。</param>
            <returns>一个Task对象，表示异步操作。</returns>
        </member>
        <member name="T:TouchSocket.Dmtp.RemoteStream._DmtpRemoteStreamPluginExtensions">
            <inheritdoc cref = "T:TouchSocket.Dmtp.RemoteStream.IDmtpRemoteStreamPlugin"/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteStream._DmtpRemoteStreamPluginExtensions.AddDmtpRemoteStreamPlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RemoteStream.LoadingStreamEventArgs,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Dmtp.RemoteStream.IDmtpRemoteStreamPlugin.OnLoadingStream(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RemoteStream.LoadingStreamEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteStream._DmtpRemoteStreamPluginExtensions.AddDmtpRemoteStreamPlugin(TouchSocket.Core.IPluginManager,System.Action{TouchSocket.Dmtp.IDmtpActorObject})">
            <inheritdoc cref = "M:TouchSocket.Dmtp.RemoteStream.IDmtpRemoteStreamPlugin.OnLoadingStream(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RemoteStream.LoadingStreamEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteStream._DmtpRemoteStreamPluginExtensions.AddDmtpRemoteStreamPlugin(TouchSocket.Core.IPluginManager,System.Action)">
            <inheritdoc cref = "M:TouchSocket.Dmtp.RemoteStream.IDmtpRemoteStreamPlugin.OnLoadingStream(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RemoteStream.LoadingStreamEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteStream._DmtpRemoteStreamPluginExtensions.AddDmtpRemoteStreamPlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Dmtp.RemoteStream.LoadingStreamEventArgs,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Dmtp.RemoteStream.IDmtpRemoteStreamPlugin.OnLoadingStream(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RemoteStream.LoadingStreamEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteStream._DmtpRemoteStreamPluginExtensions.AddDmtpRemoteStreamPlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Dmtp.IDmtpActorObject,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Dmtp.RemoteStream.IDmtpRemoteStreamPlugin.OnLoadingStream(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RemoteStream.LoadingStreamEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Dmtp.RemoteStream._DmtpRemoteStreamPluginExtensions.AddDmtpRemoteStreamPlugin(TouchSocket.Core.IPluginManager,System.Func{System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Dmtp.RemoteStream.IDmtpRemoteStreamPlugin.OnLoadingStream(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RemoteStream.LoadingStreamEventArgs)"/>
        </member>
        <member name="T:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageActor">
            <summary>
            DmtpRouterPackageActor
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageActor.#ctor(TouchSocket.Dmtp.IDmtpActor)">
            <summary>
            DmtpRouterPackageActor
            </summary>
            <param name="dmtpActor"></param>
        </member>
        <member name="P:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageActor.ReceivedRouterPackageAsync">
            <summary>
            ReceivedRouterPackage
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageActor.DmtpActor">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageActor.InputReceivedData(TouchSocket.Dmtp.DmtpMessage)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageActor.RequestAsync(System.Type,TouchSocket.Dmtp.RouterPackage.DmtpRouterPackage,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageActor.RequestAsync``1(TouchSocket.Dmtp.RouterPackage.DmtpRouterPackage,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageActor.RequestAsync(TouchSocket.Dmtp.RouterPackage.DmtpRouterPackage,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageActor.SetProtocolFlags(System.UInt16)">
            <summary>
            设置处理协议标识的起始标识。
            </summary>
            <param name="start"></param>
        </member>
        <member name="T:TouchSocket.Dmtp.RouterPackage.IDmtpRouterPackageActor">
            <summary>
            基于Dmtp协议，提供路由包访问。
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage.IDmtpRouterPackageActor.RequestAsync(System.Type,TouchSocket.Dmtp.RouterPackage.DmtpRouterPackage,System.Int32,System.Threading.CancellationToken)">
            <summary>
            请求一个路由包，并等待响应。
            </summary>
            <param name="packageType">响应包类型</param>
            <param name="package">请求的路由包</param>
            <param name="millisecondsTimeout">超时设定</param>
            <param name="token">可取消令箭</param>
            <returns>返回的响应包</returns>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage.IDmtpRouterPackageActor.RequestAsync``1(TouchSocket.Dmtp.RouterPackage.DmtpRouterPackage,System.Int32,System.Threading.CancellationToken)">
            <summary>
            请求一个路由包，并等待响应。
            </summary>
            <param name="package">请求的路由包</param>
            <param name="millisecondsTimeout">超时设定</param>
            <param name="token">可取消令箭</param>
            <returns>返回的响应包</returns>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage.IDmtpRouterPackageActor.RequestAsync(TouchSocket.Dmtp.RouterPackage.DmtpRouterPackage,System.Int32,System.Threading.CancellationToken)">
            <summary>
            请求一个路由包，并等待<see cref="T:TouchSocket.Core.Result"/>响应。
            </summary>
            <param name="package">请求的路由包</param>
            <param name="millisecondsTimeout">超时设定</param>
            <param name="token">可取消令箭</param>
            <returns>返回的响应结果</returns>
        </member>
        <member name="T:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackage">
            <summary>
            DmtpRouterPackage
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackage.PackageSize">
            <summary>
            包尺寸大小。此值并非需要精准数值，只需要估计数据即可。其作用为申请内存池。所以数据应当大小合适。
            </summary>
        </member>
        <member name="T:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageBase">
            <summary>
            DmtpRouterPackageBase
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageBase.Metadata">
            <summary>
            元数据
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageBase.Sign">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageBase.Status">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageBase.PackageRouter``1(``0@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageBase.UnpackageRouter``1(``0@)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageUtility">
            <summary>
            DmtpRouterPackageUtility
            </summary>
        </member>
        <member name="F:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageUtility.DmtpRouterPackage">
            <summary>
            DmtpRouterPackage
            </summary>
        </member>
        <member name="T:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageExtension">
            <summary>
            DmtpRouterPackageExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageExtension.GetDmtpRouterPackageActor(TouchSocket.Dmtp.IDmtpActor)">
            <summary>
            从<see cref="T:TouchSocket.Dmtp.IDmtpActor"/>中获取<see cref="T:TouchSocket.Dmtp.RouterPackage.IDmtpRouterPackageActor"/>
            </summary>
            <param name="dmtpActor"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageExtension.GetDmtpRouterPackageActor(TouchSocket.Dmtp.IDmtpActorObject)">
            <summary>
            从<see cref="T:TouchSocket.Dmtp.IDmtpActorObject"/>中获取<see cref="T:TouchSocket.Dmtp.RouterPackage.IDmtpRouterPackageActor"/>
            </summary>
            <param name="client"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageExtension.UseDmtpRouterPackage(TouchSocket.Core.IPluginManager)">
            <summary>
            使用DmtpRouterPackageActor功能
            </summary>
            <param name="pluginManager"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageFeature">
            <summary>
            提供远程路由数据包的插件功能
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageFeature.#ctor">
            <summary>
            提供远程路由数据包的插件功能
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageFeature.Loaded(TouchSocket.Core.IPluginManager)">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageFeature.ReserveProtocolSize">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageFeature.StartProtocol">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageFeature.OnDmtpHandshaking(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.DmtpVerifyEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageFeature.OnDmtpReceived(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.DmtpMessageEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageFeature.SetProtocolFlags(System.UInt16)">
            <summary>
            设置<see cref="T:TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageFeature"/>的起始协议。
            <para>
            默认起始为：60，保留5个协议长度。
            </para>
            </summary>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Dmtp.RouterPackage.RouterPackageEventArgs">
            <summary>
            RouterPackageEventArgs
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage.RouterPackageEventArgs.#ctor(TouchSocket.Dmtp.RouterPackage.DmtpRouterPackageBase,TouchSocket.Dmtp.IDmtpActor,System.UInt16)">
            <summary>
            RouterPackageEventArgs
            </summary>
            <param name="packageBase"></param>
            <param name="dmtpActor"></param>
            <param name="response"></param>
        </member>
        <member name="P:TouchSocket.Dmtp.RouterPackage.RouterPackageEventArgs.Metadata">
            <summary>
            元数据
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RouterPackage.RouterPackageEventArgs.SourceId">
            <summary>
            源Id
            </summary>
        </member>
        <member name="P:TouchSocket.Dmtp.RouterPackage.RouterPackageEventArgs.TargetId">
            <summary>
            目标Id
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage.RouterPackageEventArgs.ReadRouterPackage``1">
            <summary>
            读取请求路由包
            </summary>
            <typeparam name="TRouterPackage"></typeparam>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage.RouterPackageEventArgs.ReadRouterPackage(System.Type)">
            <summary>
            读取请求路由包
            </summary>
            <param name="routerPackageType"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage.RouterPackageEventArgs.ResponseAsync(TouchSocket.Dmtp.RouterPackage.DmtpRouterPackage)">
            <summary>
            响应数据
            </summary>
            <param name="package"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage.RouterPackageEventArgs.ResponseFailAsync(System.String)">
            <summary>
            响应一个失败操作。
            <para>
            注意：请求方必须使用<see cref="M:TouchSocket.Dmtp.RouterPackage.IDmtpRouterPackageActor.RequestAsync(TouchSocket.Dmtp.RouterPackage.DmtpRouterPackage,System.Int32,System.Threading.CancellationToken)"/>
            </para>
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage.RouterPackageEventArgs.ResponseResultAsync(TouchSocket.Core.Result)">
            <summary>
            响应一个<see cref="T:TouchSocket.Core.Result"/>
            <para>
            注意：请求方必须使用<see cref="M:TouchSocket.Dmtp.RouterPackage.IDmtpRouterPackageActor.RequestAsync(TouchSocket.Dmtp.RouterPackage.DmtpRouterPackage,System.Int32,System.Threading.CancellationToken)"/>
            </para>
            </summary>
            <param name="result"></param>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage.RouterPackageEventArgs.ResponseSuccessAsync(System.String)">
            <summary>
            响应一个成功操作。
            <para>
            注意：请求方必须使用<see cref="M:TouchSocket.Dmtp.RouterPackage.IDmtpRouterPackageActor.RequestAsync(TouchSocket.Dmtp.RouterPackage.DmtpRouterPackage,System.Int32,System.Threading.CancellationToken)"/>
            </para>
            </summary>
            <param name="msg"></param>
        </member>
        <member name="T:TouchSocket.Dmtp.RouterPackage.IDmtpRouterPackagePlugin">
            <summary>
            定义了一个DMTP路由包插件，该插件扩展了IPlugin接口。
            </summary>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage.IDmtpRouterPackagePlugin.OnReceivedRouterPackage(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RouterPackage.RouterPackageEventArgs)">
            <summary>
            在远程请求加载流时触发。
            </summary>
            <param name="client">发起请求的客户端对象。</param>
            <param name="e">包含路由包信息的事件参数。</param>
            <returns>一个任务，表示异步操作。</returns>
        </member>
        <member name="T:TouchSocket.Dmtp.RouterPackage._DmtpRouterPackagePluginExtensions">
            <inheritdoc cref = "T:TouchSocket.Dmtp.RouterPackage.IDmtpRouterPackagePlugin"/>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage._DmtpRouterPackagePluginExtensions.AddDmtpRouterPackagePlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RouterPackage.RouterPackageEventArgs,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Dmtp.RouterPackage.IDmtpRouterPackagePlugin.OnReceivedRouterPackage(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RouterPackage.RouterPackageEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage._DmtpRouterPackagePluginExtensions.AddDmtpRouterPackagePlugin(TouchSocket.Core.IPluginManager,System.Action{TouchSocket.Dmtp.IDmtpActorObject})">
            <inheritdoc cref = "M:TouchSocket.Dmtp.RouterPackage.IDmtpRouterPackagePlugin.OnReceivedRouterPackage(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RouterPackage.RouterPackageEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage._DmtpRouterPackagePluginExtensions.AddDmtpRouterPackagePlugin(TouchSocket.Core.IPluginManager,System.Action)">
            <inheritdoc cref = "M:TouchSocket.Dmtp.RouterPackage.IDmtpRouterPackagePlugin.OnReceivedRouterPackage(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RouterPackage.RouterPackageEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage._DmtpRouterPackagePluginExtensions.AddDmtpRouterPackagePlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Dmtp.RouterPackage.RouterPackageEventArgs,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Dmtp.RouterPackage.IDmtpRouterPackagePlugin.OnReceivedRouterPackage(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RouterPackage.RouterPackageEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage._DmtpRouterPackagePluginExtensions.AddDmtpRouterPackagePlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Dmtp.IDmtpActorObject,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Dmtp.RouterPackage.IDmtpRouterPackagePlugin.OnReceivedRouterPackage(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RouterPackage.RouterPackageEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Dmtp.RouterPackage._DmtpRouterPackagePluginExtensions.AddDmtpRouterPackagePlugin(TouchSocket.Core.IPluginManager,System.Func{System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Dmtp.RouterPackage.IDmtpRouterPackagePlugin.OnReceivedRouterPackage(TouchSocket.Dmtp.IDmtpActorObject,TouchSocket.Dmtp.RouterPackage.RouterPackageEventArgs)"/>
        </member>
        <member name="T:TouchSocket.Resources.TouchSocketProDmtpResource">
            <summary>
              一个强类型的资源类，用于查找本地化的字符串等。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketProDmtpResource.ResourceManager">
            <summary>
              返回此类使用的缓存的 ResourceManager 实例。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketProDmtpResource.Culture">
            <summary>
              重写当前线程的 CurrentUICulture 属性，对
              使用此强类型资源类的所有资源查找执行重写。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketProDmtpResource.DmtpRemoteAccessActorNull">
            <summary>
              查找类似 DmtpRemoteAccessActor is empty, it may be necessary to enable the DmtpRemoteAccess plugin. 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketProDmtpResource.DmtpRemoteStreamActorNull">
            <summary>
              查找类似 DmtpRemoteStreamActor is empty, it may be necessary to enable the DmtpRemoteStream plugin. 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketProDmtpResource.DmtpRouterPackageActorNull">
            <summary>
              查找类似 DmtpRoutePackageActor is empty, it may be necessary to enable the DmtpRoutePackage plugin. 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketProDmtpResource.NotFindAnyTargetId">
            <summary>
              查找类似 No available target IDs were found. 的本地化字符串。
            </summary>
        </member>
        <member name="T:TouchSocket.Resources.TouchSocketProDmtpStatus">
            <summary>
            TouchSocketDmtpStatus
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketProDmtpStatus.UnknownError">
            <summary>
            未知错误
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketProDmtpStatus.Success">
            <summary>
            操作成功
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketProDmtpStatus.Overtime">
            <summary>
            操作超时
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketProDmtpStatus.Canceled">
            <summary>
            用户主动取消操作。
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketProDmtpStatus.Exception">
             <summary>
            发生异常，信息：{0}。
             </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketProDmtpStatus.RoutingNotAllowed">
            <summary>
            不允许路由该包，信息：{0}。
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketProDmtpStatus.RemoteRefuse">
            <summary>
            远程终端拒绝该操作，反馈信息：{0}。
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketProDmtpStatus.ClientNotFind">
            <summary>
            没有找到Id为{0}的客户端。
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketProDmtpStatus.NotFindAnyTargetId">
            <summary>
            没有找到任何可用的目标Id。
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketProDmtpStatus.ResourceHandleNotFind">
            <summary>
            资源句柄{0}对应的资源没有找到，可能操作已超时。
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketProDmtpStatus.StreamBucketNull">
            <summary>
            接收流容器为空
            </summary>
        </member>
        <member name="F:TouchSocket.Resources.TouchSocketProDmtpStatus.RoutingNotSupported">
            <summary>
            响应方不支持路由操作。
            </summary>
        </member>
        <member name="T:TouchSocket.Resources.TouchSocketProDmtpStatusExtension">
            <summary>
            StatusExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Resources.TouchSocketProDmtpStatusExtension.ToStatus(System.Byte)">
            <summary>
            转为状态字
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Resources.TouchSocketProDmtpStatusExtension.ToValue(TouchSocket.Resources.TouchSocketProDmtpStatus)">
            <summary>
            转为数值
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.FastSerializableAttribute">
            <summary>
            标识源生成Fast序列化相关的实现。
            </summary>
        </member>
        <member name="T:TouchSocket.Core.GeneratorPackageAttribute">
            <summary>
            标识源生成<see cref="T:TouchSocket.Core.IPackage"/>的实现。
            </summary>
        </member>
        <member name="T:TouchSocket.Core.PackageMemberAttribute">
            <summary>
            标识源生成<see cref="T:TouchSocket.Core.IPackage"/>成员的特性。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.PackageMemberAttribute.Behavior">
            <summary>
            生成行为。一般来说，对于非只读、非重写、且同时拥有get，set（可以私有）访问器的属性，会自动生成。
            对于字段，均不会自动生成。所以可以使用该设置，来指示生成器的生成行为。
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.ConstantExpectedAttribute">
            <summary>
            Indicates that the specified method parameter expects a constant.
            </summary>
            <remarks>
            This can be used to inform tooling that a constant should be used as an argument for the annotated parameter.
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.ConstantExpectedAttribute.Min">
            <summary>
            Indicates the minimum bound of the expected constant, inclusive.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.ConstantExpectedAttribute.Max">
            <summary>
            Indicates the maximum bound of the expected constant, inclusive.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.ExperimentalAttribute">
            <summary>
            Indicates that an API is experimental and it may change in the future.
            </summary>
            <remarks>
            This attribute allows call sites to be flagged with a diagnostic that indicates that an experimental
            feature is used. Authors can use this attribute to ship preview features in their assemblies.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.ExperimentalAttribute"/> class,
            specifying the ID that the compiler will use when reporting a use of the API the attribute applies to.
            </summary>
            <param name="diagnosticId">The ID that the compiler will use when reporting a use of the API the attribute applies to.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.DiagnosticId">
            <summary>
            Gets the ID that the compiler will use when reporting a use of the API the attribute applies to.
            </summary>
            <value>The unique diagnostic ID.</value>
            <remarks>
            The diagnostic ID is shown in build output for warnings and errors.
            <para>This property represents the unique ID that can be used to suppress the warnings or errors, if needed.</para>
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.UrlFormat">
            <summary>
            Gets or sets the URL for corresponding documentation.
            The API accepts a format string instead of an actual URL, creating a generic URL that includes the diagnostic ID.
            </summary>
            <value>The format string that represents a URL to corresponding documentation.</value>
            <remarks>An example format string is <c>https://contoso.com/obsoletion-warnings/{0}</c>.</remarks>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>
            Specifies that the method or property will ensure that the listed field and property members have not-null values.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)">
            <summary>
            Initializes the attribute with a field or property member.
            </summary>
            <param name="member">The field or property member that is promised to be not-null.</param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])">
            <summary>
            Initializes the attribute with the list of field and property members.
            </summary>
            <param name="members">The list of field and property members that are promised to be not-null.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.Members">
            <summary>
            Gets field or property member names.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>
            Specifies that the method or property will ensure that the listed field and property
            members have not-null values when returning with the specified return value condition.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)">
            <summary>
            Initializes the attribute with the specified return value condition and a field or property member.
            </summary>
            <param name="returnValue">The return value condition. If the method returns this value, the associated parameter will not be null.</param>
            <param name="member">The field or property member that is promised to be not-null.</param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])">
            <summary>
            Initializes the attribute with the specified return value condition and list of field and property members.
            </summary>
            <param name="returnValue">The return value condition. If the method returns this value, the associated parameter will not be null.</param>
            <param name="members">The list of field and property members that are promised to be not-null.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.ReturnValue">
            <summary>
            Gets the return value condition.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.Members">
            <summary>
            Gets field or property member names.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute">
            <summary>
            Specifies that this constructor sets all required members for the current type,
            and callers do not need to set any required members themselves.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute">
            <summary>
            Specifies the syntax used in a string.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.#ctor(System.String)">
            <summary>
            Initializes the <see cref="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute"/> with the identifier of the syntax used.
            </summary>
            <param name="syntax">The syntax identifier.</param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.#ctor(System.String,System.Object[])">
            <summary>Initializes the <see cref="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute"/> with the identifier of the syntax used.</summary>
            <param name="syntax">The syntax identifier.</param>
            <param name="arguments">Optional arguments associated with the specific syntax employed.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Syntax">
            <summary>Gets the identifier of the syntax used.</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Arguments">
            <summary>Optional arguments associated with the specific syntax employed.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.CompositeFormat">
            <summary>The syntax identifier for strings containing composite formats for string formatting.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.DateOnlyFormat">
            <summary>The syntax identifier for strings containing date format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.DateTimeFormat">
            <summary>The syntax identifier for strings containing date and time format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.EnumFormat">
            <summary>The syntax identifier for strings containing <see cref="T:System.Enum"/> format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.GuidFormat">
            <summary>The syntax identifier for strings containing <see cref="T:System.Guid"/> format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Json">
            <summary>The syntax identifier for strings containing JavaScript Object Notation (JSON).</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.NumericFormat">
            <summary>The syntax identifier for strings containing numeric format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Regex">
            <summary>The syntax identifier for strings containing regular expressions.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.TimeOnlyFormat">
            <summary>The syntax identifier for strings containing time format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.TimeSpanFormat">
            <summary>The syntax identifier for strings containing <see cref="T:System.TimeSpan"/> format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Uri">
            <summary>The syntax identifier for strings containing URIs.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Xml">
            <summary>The syntax identifier for strings containing XML.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute">
            <summary>
            Used to indicate a byref escapes and is not scoped.
            </summary>
            <remarks>
            <para>
            There are several cases where the C# compiler treats a <see langword="ref"/> as implicitly
            <see langword="scoped"/> - where the compiler does not allow the <see langword="ref"/> to escape the method.
            </para>
            <para>
            For example:
            <list type="number">
                <item><see langword="this"/> for <see langword="struct"/> instance methods.</item>
                <item><see langword="ref"/> parameters that refer to <see langword="ref"/> <see langword="struct"/> types.</item>
                <item><see langword="out"/> parameters.</item>
            </list>
            </para>
            <para>
            This attribute is used in those instances where the <see langword="ref"/> should be allowed to escape.
            </para>
            <para>
            Applying this attribute, in any form, has impact on consumers of the applicable API. It is necessary for
            API authors to understand the lifetime implications of applying this attribute and how it may impact their users.
            </para>
            </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute">
            <summary>
            An attribute that allows parameters to receive the expression of other parameters.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute"/> class.
            </summary>
            <param name="parameterName">The condition parameter value.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute.ParameterName">
            <summary>
            Gets the parameter name the expression is retrieved from.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.CollectionBuilderAttribute.#ctor(System.Type,System.String)">
            <summary>
            Initialize the attribute to refer to the <paramref name="methodName"/> method on the <paramref name="builderType"/> type.
            </summary>
            <param name="builderType">The type of the builder to use to construct the collection.</param>
            <param name="methodName">The name of the method on the builder to use to construct the collection.</param>
            <remarks>
            <paramref name="methodName"/> must refer to a static method that accepts a single parameter of
            type <see cref="T:System.ReadOnlySpan`1"/> and returns an instance of the collection being built containing
            a copy of the data from that span.  In future releases of .NET, additional patterns may be supported.
            </remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.CollectionBuilderAttribute.BuilderType">
            <summary>
            Gets the type of the builder to use to construct the collection.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.CollectionBuilderAttribute.MethodName">
            <summary>
            Gets the name of the method on the builder to use to construct the collection.
            </summary>
            <remarks>
            This should match the metadata name of the target method.
            For example, this might be ".ctor" if targeting the type's constructor.
            </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute">
            <summary>
            Indicates that compiler support for a particular feature is required for the location where this attribute is applied.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.#ctor(System.String)">
            <summary>
            Creates a new instance of the <see cref="T:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute"/> type.
            </summary>
            <param name="featureName">The name of the feature to indicate.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName">
            <summary>
            The name of the compiler feature.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.IsOptional">
            <summary>
            If true, the compiler can choose to allow access to the location where this attribute is applied if it does not understand <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/>.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.RefStructs">
            <summary>
            The <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/> used for the ref structs C# feature.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.RequiredMembers">
            <summary>
            The <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/> used for the required members C# feature.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute">
            <summary>
            Indicates which arguments to a method involving an interpolated string handler should be passed to that handler.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.
            </summary>
            <param name="argument">The name of the argument that should be passed to the handler.</param>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.
            </summary>
            <param name="arguments">The names of the arguments that should be passed to the handler.</param>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.Arguments">
            <summary>
            Gets the names of the arguments that should be passed to the handler.
            </summary>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute">
            <summary>
            Indicates the attributed type is to be used as an interpolated string handler.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.IsExternalInit">
            <summary>
            Reserved to be used by the compiler for tracking metadata.
            This class should not be used by developers in source code.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.ModuleInitializerAttribute">
             <summary>
             Used to indicate to the compiler that a method should be called
             in its containing module's initializer.
             </summary>
             <remarks>
             When one or more valid methods
             with this attribute are found in a compilation, the compiler will
             emit a module initializer which calls each of the attributed methods.
            
             Certain requirements are imposed on any method targeted with this attribute:
             - The method must be `static`.
             - The method must be an ordinary member method, as opposed to a property accessor, constructor, local function, etc.
             - The method must be parameterless.
             - The method must return `void`.
             - The method must not be generic or be contained in a generic type.
             - The method's effective accessibility must be `internal` or `public`.
            
             The specification for module initializers in the .NET runtime can be found here:
             https://github.com/dotnet/runtime/blob/main/docs/design/specs/Ecma-335-Augments.md#module-initializer
             </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute">
            <summary>
            Specifies the priority of a member in overload resolution. When unspecified, the default priority is 0.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute"/> class.
            </summary>
            <param name="priority">The priority of the attributed member. Higher numbers are prioritized, lower numbers are deprioritized. 0 is the default if no attribute is present.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute.Priority">
            <summary>
            The priority of the member.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.ParamCollectionAttribute">
            <summary>
            Indicates that a method will allow a variable number of arguments in its invocation.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.RequiredMemberAttribute">
            <summary>
            Specifies that a type has required members or that a member is required.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.RequiresLocationAttribute">
            <summary>
            Reserved for use by a compiler for tracking metadata.
            This attribute should not be used by developers in source code.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.SkipLocalsInitAttribute">
            <summary>
            Used to indicate to the compiler that the <c>.locals init</c> flag should not be set in method headers.
            </summary>
        </member>
        <member name="M:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute"/> class.
            </summary>
        </member>
        <member name="M:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute"/> class with the specified message.
            </summary>
            <param name="message">An optional message associated with this attribute instance.</param>
        </member>
        <member name="P:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute.Message">
            <summary>
            Returns the optional message associated with this attribute instance.
            </summary>
        </member>
        <member name="P:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute.Url">
            <summary>
            Returns the optional URL associated with this attribute instance.
            </summary>
        </member>
    </members>
</doc>

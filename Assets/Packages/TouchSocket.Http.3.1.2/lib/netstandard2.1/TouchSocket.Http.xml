<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TouchSocket.Http</name>
    </assembly>
    <members>
        <member name="T:TouchSocket.Http.HttpBase">
            <summary>
            Http基础头部
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpBase.MaxCacheSize">
            <summary>
            定义缓存的最大大小，这里设置为100MB。
            这个值是根据预期的内存使用量和性能需求确定的。
            过大的缓存可能会导致内存使用率过高，影响系统的其他部分。
            过小的缓存则可能无法有效减少对外部资源的访问，降低程序的运行效率。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpBase.ServerVersion">
            <summary>
            服务器版本
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.Accept">
            <summary>
            可接受MIME类型
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.AcceptEncoding">
            <summary>
            允许编码
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.Content">
            <summary>
            获取或设置HTTP内容。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.ContentCompleted">
            <summary>
            内容填充完成
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.ContentLength">
            <summary>
            内容长度
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.ContentType">
            <summary>
            内容类型
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.Headers">
            <summary>
            请求头集合
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.IsServer">
            <summary>
            是否在Server端工作
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.Protocols">
            <summary>
            协议名称，默认HTTP
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpBase.ProtocolVersion">
            <summary>
            HTTP协议版本，默认1.1
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpBase.ReadRequestLine(System.ReadOnlySpan{System.Byte})">
            <summary>
            读取请求行。
            </summary>
            <param name="requestLineSpan">包含请求行的只读字节跨度。</param>
        </member>
        <member name="M:TouchSocket.Http.HttpBase.GetContentAsync(System.Threading.CancellationToken)">
            <summary>
            获取一次性内容。
            </summary>
            <returns>返回一个包含字节的只读内存的任务。</returns>
            <param name="cancellationToken">用于取消异步操作的令牌。</param>
        </member>
        <member name="M:TouchSocket.Http.HttpBase.ReadAsync(System.Threading.CancellationToken)">
            <summary>
            异步读取HTTP块段的内容。
            </summary>
            <param name="cancellationToken">用于取消异步操作的令牌。</param>
            <returns>返回一个<see cref="T:TouchSocket.Core.IReadOnlyMemoryBlockResult"/>，表示异步读取操作的结果。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpBase.ReadCopyToAsync(System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            异步读取并复制流数据
            </summary>
            <param name="stream">需要读取并复制的流</param>
            <param name="cancellationToken">异步操作的取消令牌</param>
            <returns>一个异步任务，表示复制操作的完成</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpBase.ReadCopyToAsync(System.IO.Stream,TouchSocket.Http.HttpFlowOperator)">
            <summary>
            异步读取并复制流数据
            </summary>
            <param name="stream">需要读取并复制的流</param>
            <param name="flowOperator">用于控制流操作的HttpFlowOperator实例</param>
            <returns>一个表示操作结果的Result任务</returns>
        </member>
        <member name="T:TouchSocket.Http.HttpContext">
            <summary>
            Http上下文
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpContext.#ctor(TouchSocket.Http.HttpRequest,TouchSocket.Http.HttpResponse)">
            <summary>
            初始化 <see cref="T:TouchSocket.Http.HttpContext"/> 类的新实例。
            </summary>
            <param name="request">Http请求</param>
            <param name="response">Http响应</param>
        </member>
        <member name="P:TouchSocket.Http.HttpContext.Request">
            <summary>
            Http请求
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpContext.Response">
            <summary>
            Http响应
            </summary>
        </member>
        <member name="T:TouchSocket.Http.HttpHeaders">
            <summary>
            请求头静态类
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.CacheControl">
            <summary>
            Cache-Control 标头，指定请求/响应链上所有缓存控制机制必须服从的指令。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Connection">
            <summary>
            Connection 标头，指定特定连接需要的选项。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Date">
            <summary>
            Date 标头，指定开始创建请求的日期和时间。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.KeepAlive">
            <summary>
            Keep-Alive 标头，指定用以维护持久性连接的参数。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Pragma">
            <summary>
            Pragma 标头，指定可应用于请求/响应链上的任何代理的特定于实现的指令。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Trailer">
            <summary>
            Trailer 标头，指定标头字段显示在以 chunked 传输编码方式编码的消息的尾部。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.TransferEncoding">
            <summary>
            Transfer-Encoding 标头，指定对消息正文应用的转换的类型（如果有）。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Upgrade">
            <summary>
            Upgrade 标头，指定客户端支持的附加通信协议。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Via">
            <summary>
            Via 标头，指定网关和代理程序要使用的中间协议。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Warning">
            <summary>
            Warning 标头，指定关于可能未在消息中反映的消息的状态或转换的附加信息。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Allow">
            <summary>
            Allow 标头，指定支持的 HTTP 方法集。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ContentLength">
            <summary>
            Content-Length 标头，指定伴随正文数据的长度（以字节为单位）。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ContentType">
            <summary>
            Content-Type 标头，指定伴随正文数据的 MIME 类型。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ContentEncoding">
            <summary>
            Content-Encoding 标头，指定已应用于伴随正文数据的编码。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ContentLanguage">
            <summary>
            Content-Langauge 标头，指定伴随正文数据的自然语言。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ContentLocation">
            <summary>
            Content-Location 标头，指定可从其中获得伴随正文的 URI。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ContentMd5">
            <summary>
            Content-MD5 标头，指定伴随正文数据的 MD5 摘要，用于提供端到端消息完整性检查。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ContentRange">
            <summary>
            Content-Range 标头，指定在完整正文中应用伴随部分正文数据的位置。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Expires">
            <summary>
            Expires 标头，指定日期和时间，在此之后伴随的正文数据应视为陈旧的。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.LastModified">
            <summary>
            Last-Modified 标头，指定上次修改伴随的正文数据的日期和时间。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Accept">
            <summary>
            Accept 标头，指定响应可接受的 MIME 类型。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.AcceptCharset">
            <summary>
            Accept-Charset 标头，指定响应可接受的字符集。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.AcceptEncoding">
            <summary>
            Accept-Encoding 标头，指定响应可接受的内容编码。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.AcceptLanguage">
            <summary>
            Accept-Langauge 标头，指定响应首选的自然语言。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Authorization">
            <summary>
            Authorization 标头，指定客户端为向服务器验证自身身份而出示的凭据。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Cookie">
            <summary>
            Cookie 标头，指定向服务器提供的 Cookie 数据。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Expect">
            <summary>
            Expect 标头，指定客户端要求的特定服务器行为。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.From">
            <summary>
            From 标头，指定控制请求用户代理的用户的 Internet 电子邮件地址。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Host">
            <summary>
            Host 标头，指定所请求资源的主机名和端口号。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.IfMatch">
            <summary>
            If-Match 标头，指定仅当客户端的指示资源的缓存副本是最新的时，才执行请求的操作。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.IfModifiedSince">
            <summary>
            If-Modified-Since 标头，指定仅当自指示的数据和时间之后修改了请求的资源时，才执行请求的操作。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.IfNoneMatch">
            <summary>
            If-None-Match 标头，指定仅当客户端的指示资源的缓存副本都不是最新的时，才执行请求的操作。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.IfRange">
            <summary>
            If-Range 标头，指定如果客户端的缓存副本是最新的，仅发送指定范围的请求资源。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.IfUnmodifiedSince">
            <summary>
            If-Unmodified-Since 标头，指定仅当自指示的日期和时间之后修改了请求的资源时，才执行请求的操作。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.MaxForwards">
            <summary>
            Max-Forwards 标头，指定一个整数，表示此请求还可转发的次数。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ProxyAuthorization">
            <summary>
            Proxy-Authorization 标头，指定客户端为向代理验证自身身份而出示的凭据。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Referer">
            <summary>
            Referer 标头，指定从中获得请求 URI 的资源的 URI。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Range">
            <summary>
            Range 标头，指定代替整个响应返回的客户端请求的响应的子范围。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Te">
            <summary>
            TE 标头，指定响应可接受的传输编码方式。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Translate">
            <summary>
            Translate 标头，与 WebDAV 功能一起使用的 HTTP 规范的 Microsoft 扩展。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.UserAgent">
            <summary>
            User-Agent 标头，指定有关客户端代理的信息。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.AcceptRanges">
            <summary>
            Accept-Ranges 标头，指定服务器接受的范围。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Age">
            <summary>
            Age 标头，指定自起始服务器生成响应以来的时间长度（以秒为单位）。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ETag">
            <summary>
            Etag 标头，指定请求的变量的当前值。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Location">
            <summary>
            Location 标头，指定为获取请求的资源而将客户端重定向到的 URI。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ProxyAuthenticate">
            <summary>
            Proxy-Authenticate 标头，指定客户端必须对代理验证其自身。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.RetryAfter">
            <summary>
            Retry-After 标头，指定某个时间（以秒为单位）或日期和时间，在此时间之后客户端可以重试其请求。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Server">
            <summary>
            Server 标头，指定关于起始服务器代理的信息。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.SetCookie">
            <summary>
            Set-Cookie 标头，指定提供给客户端的 Cookie 数据。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Vary">
            <summary>
            Vary 标头，指定用于确定缓存的响应是否为新响应的请求标头。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.WwwAuthenticate">
            <summary>
            WWW-Authenticate 标头，指定客户端必须对服务器验证其自身。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.Origin">
            <summary>
            Origin。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpHeaders.ContentDisposition">
            <summary>
            Content-Disposition
            </summary>
        </member>
        <member name="T:TouchSocket.Http.HttpMethod">
            <summary>
            HttpMethod
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpMethod.m_value">
            <summary>
            值
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpMethod.Get">
            <summary>
            Get
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpMethod.Post">
            <summary>
            Post
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpMethod.Put">
            <summary>
            Put
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpMethod.Delete">
            <summary>
            Delete
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpMethod.#ctor(System.String)">
            <summary>
            表示
            </summary>
            <param name="value">值</param>
        </member>
        <member name="M:TouchSocket.Http.HttpMethod.op_Implicit(System.String)~TouchSocket.Http.HttpMethod">
            <summary>
            由字符串向<see cref="T:TouchSocket.Http.HttpMethod"/>转换
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpMethod.ToString">
            <summary>
            转换为字符串
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.HttpProxy">
            <summary>
            Http代理
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpProxy.#ctor(TouchSocket.Sockets.IPHost)">
            <summary>
            不带基本验证的代理
            </summary>
            <param name="host"></param>
        </member>
        <member name="M:TouchSocket.Http.HttpProxy.#ctor(TouchSocket.Sockets.IPHost,System.String,System.String)">
            <summary>
            带基本验证的代理
            </summary>
            <param name="host"></param>
            <param name="userName"></param>
            <param name="passWord"></param>
        </member>
        <member name="P:TouchSocket.Http.HttpProxy.Credential">
            <summary>
            验证代理
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpProxy.Host">
            <summary>
            代理的地址
            </summary>
        </member>
        <member name="T:TouchSocket.Http.HttpRange">
            <summary>
            Range: bytes=0-499 表示第 0-499 字节范围的内容
            Range: bytes=500-999 表示第 500-999 字节范围的内容
            Range: bytes=-500 表示最后 500 字节的内容
            Range: bytes=500- 表示从第 500 字节开始到文件结束部分的内容
            Range: bytes=0-0,-1 表示第一个和最后一个字节
            Range: bytes=500-600,601-999 同时指定几个范围
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpRange.GetRanges(System.String,System.Int64)">
            <summary>
            转换获取的集合
            </summary>
            <param name="rangeStr"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpRange.GetRange(System.String,System.Int64)">
            <summary>
            转换获取的集合
            </summary>
            <param name="rangeStr"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="P:TouchSocket.Http.HttpRange.Start">
            <summary>
            起始位置
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpRange.Length">
            <summary>
            长度
            </summary>
        </member>
        <member name="T:TouchSocket.Http.HttpRequest">
            <summary>
            HTTP请求定义
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.#ctor">
            <summary>
            HttpRequest类的构造函数。
            </summary>
            <remarks>
            初始化HttpRequest对象的基本属性。
            </remarks>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.#ctor(TouchSocket.Http.HttpClientBase)">
            <summary>
            初始化 HttpRequest 实例。
            </summary>
            <param name="httpClientBase">提供底层 HTTP 通信功能的 HttpClientBase 实例。</param>
        </member>
        <member name="P:TouchSocket.Http.HttpRequest.Content">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.HttpRequest.KeepAlive">
            <summary>
            保持连接。
            <para>
            一般的，当是http1.1时，如果没有显式的Connection: close，即返回true。当是http1.0时，如果没有显式的Connection: Keep-Alive，即返回false。
            </para>
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpRequest.IsServer">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.HttpRequest.Method">
            <summary>
            HTTP请求方式。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpRequest.Query">
            <summary>
            url参数
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpRequest.RelativeURL">
            <summary>
            相对路径（不含参数）
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpRequest.URL">
            <summary>
            Url全地址，包含参数
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.GetContentAsync(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.ReadAsync(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.SetProxyHost(System.String)">
            <summary>
            设置代理Host
            </summary>
            <param name="host">代理服务器的地址</param>
            <returns>返回当前HttpRequest实例，以支持链式调用</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.InternalSetContent(System.ReadOnlyMemory{System.Byte}@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.ResetHttp">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpRequest.ReadRequestLine(System.ReadOnlySpan{System.Byte})">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.HttpResponse">
            <summary>
            Http响应
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.#ctor(TouchSocket.Http.HttpClientBase)">
            <summary>
            Http响应
            </summary>
            <param name="httpClientBase"></param>
        </member>
        <member name="P:TouchSocket.Http.HttpResponse.IsChunk">
            <summary>
            是否分块
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpResponse.IsProxyAuthenticationRequired">
            <summary>
            是否代理权限验证。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpResponse.IsRedirect">
            <summary>
            是否重定向
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpResponse.IsServer">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.HttpResponse.Responsed">
            <summary>
            是否已经响应数据。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpResponse.StatusCode">
            <summary>
            状态码，默认200
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpResponse.StatusMessage">
            <summary>
            状态消息，默认Success
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.AnswerAsync(System.Threading.CancellationToken)">
            <summary>
            构建数据并回应。
            <para>该方法仅在具有Client实例时有效。</para>
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.CompleteChunkAsync">
            <summary>
            当传输模式是Chunk时，用于结束传输。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.GetContentAsync(System.Threading.CancellationToken)">
            <inheritdoc/>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.ReadAsync(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.InternalSetContent(System.ReadOnlyMemory{System.Byte}@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.WriteAsync(System.ReadOnlyMemory{System.Byte})">
            <summary>
            异步写入指定的只读内存数据。
            </summary>
            <param name="memory">要写入的只读内存数据。</param>
            <returns>一个任务，表示异步写入操作。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpResponse.ReadRequestLine(System.ReadOnlySpan{System.Byte})">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.HttpResponseResult">
            <summary>
            HTTP响应结果结构体，实现了IDisposable接口，用于在使用后释放相关资源。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpResponseResult.m_action">
            <summary>
            一个操作委托，用于在Dispose时执行特定操作以释放资源。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpResponseResult.#ctor(TouchSocket.Http.HttpResponse,System.Action)">
            <summary>
            初始化HttpResponseResult结构体。
            </summary>
            <param name="response">HTTP响应对象，用于处理HTTP请求的响应。</param>
            <param name="action">一个Action委托，将在Dispose方法中调用，用于执行资源释放操作。</param>
        </member>
        <member name="P:TouchSocket.Http.HttpResponseResult.Response">
            <summary>
            获取HTTP响应对象。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpResponseResult.Dispose">
            <summary>
            执行资源释放操作。调用构造函数中传入的Action委托以执行具体释放逻辑。
            </summary>
        </member>
        <member name="T:TouchSocket.Http.HttpStatusCode">
            <summary>
            包含RFC 2616中定义的HTTP 1.1状态码值
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.Continue">
            <summary>
            表示客户端可以继续其请求，对应HTTP状态码100
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.SwitchingProtocols">
            <summary>
            表示协议版本或协议正在变更，对应HTTP状态码101
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.Processing">
            <summary>
            表示服务器已接受完整请求但尚未完成处理，对应HTTP状态码102
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.EarlyHints">
            <summary>
            向客户端提示服务器可能会发送包含此信息性响应中头部字段的最终响应，对应HTTP状态码103
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.OK">
            <summary>
            请求成功，请求的信息包含在响应中，这是最常见的状态码，对应HTTP状态码200
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.Created">
            <summary>
            请求导致在发送响应前创建了新资源，对应HTTP状态码201
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.Accepted">
            <summary>
            请求已接受并将进行后续处理，对应HTTP状态码202
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.NonAuthoritativeInformation">
            <summary>
            返回的元信息来自缓存副本而非原始服务器，因此可能不正确，对应HTTP状态码203
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.NoContent">
            <summary>
            请求已成功处理，响应故意为空，对应HTTP状态码204
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.ResetContent">
            <summary>
            客户端应重置（而非重新加载）当前资源，对应HTTP状态码205
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.PartialContent">
            <summary>
            响应是根据包含字节范围的GET请求返回的部分响应，对应HTTP状态码206
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.MultiStatus">
            <summary>
            在WebDAV操作中，单个响应包含多个状态码，响应体包含描述状态码的XML，对应HTTP状态码207
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.AlreadyReported">
            <summary>
            WebDAV绑定的成员已在之前的多状态响应部分中枚举，不再重复包含，对应HTTP状态码208
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.IMUsed">
            <summary>
            服务器已完成资源请求，响应是对当前实例应用一个或多个实例操作结果的表示，对应HTTP状态码226
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.Ambiguous">
            <summary>
            请求的信息有多个表示形式（与MultipleChoices同义），默认行为是视为重定向并跟随Location头部，对应HTTP状态码300
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.MultipleChoices">
            <summary>
            请求的信息有多个表示形式（与Ambiguous同义），默认行为是视为重定向并跟随Location头部，对应HTTP状态码300
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.Moved">
            <summary>
            请求的信息已永久移动到Location头部指定的URI（与MovedPermanently同义），默认跟随重定向，POST请求重定向时改用GET方法，对应HTTP状态码301
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.MovedPermanently">
            <summary>
            请求的信息已永久移动到Location头部指定的URI（与Moved同义），默认跟随重定向，POST请求重定向时改用GET方法，对应HTTP状态码301
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.Found">
            <summary>
            请求的信息位于Location头部指定的URI（与Redirect同义），默认跟随重定向，POST请求重定向时改用GET方法，对应HTTP状态码302
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.Redirect">
            <summary>
            请求的信息位于Location头部指定的URI（与Found同义），默认跟随重定向，POST请求重定向时改用GET方法，对应HTTP状态码302
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.RedirectMethod">
            <summary>
            作为POST请求的结果，自动将客户端重定向到Location头部指定的URI（与SeeOther同义），重定向请求使用GET方法，对应HTTP状态码303
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.SeeOther">
            <summary>
            作为POST请求的结果，自动将客户端重定向到Location头部指定的URI（与RedirectMethod同义），重定向请求使用GET方法，对应HTTP状态码303
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.NotModified">
            <summary>
            客户端的缓存副本是最新的，不传输资源内容，对应HTTP状态码304
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.UseProxy">
            <summary>
            请求应使用Location头部指定的代理服务器，对应HTTP状态码305
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.Unused">
            <summary>
            未使用，是HTTP/1.1规范的一个未完全指定的扩展提案，对应HTTP状态码306
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.RedirectKeepVerb">
            <summary>
            请求的信息位于Location头部指定的URI（与TemporaryRedirect同义），默认跟随重定向，POST请求重定向时保持使用POST方法，对应HTTP状态码307
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.TemporaryRedirect">
            <summary>
            请求的信息位于Location头部指定的URI（与RedirectKeepVerb同义），默认跟随重定向，POST请求重定向时保持使用POST方法，对应HTTP状态码307
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.PermanentRedirect">
            <summary>
            请求的信息永久位于Location头部指定的URI，默认跟随重定向，POST请求重定向时保持使用POST方法，对应HTTP状态码308
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.BadRequest">
            <summary>
            服务器无法理解请求，当没有其他适用错误或确切错误未知时返回，对应HTTP状态码400
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.Unauthorized">
            <summary>
            请求的资源需要身份验证，WWW-Authenticate头部包含身份验证细节，对应HTTP状态码401
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.PaymentRequired">
            <summary>
            为未来使用保留，对应HTTP状态码402
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.Forbidden">
            <summary>
            服务器拒绝处理请求，对应HTTP状态码403
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.NotFound">
            <summary>
            请求的资源在服务器上不存在，对应HTTP状态码404
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.MethodNotAllowed">
            <summary>
            请求方法（POST或GET）不被请求的资源允许，对应HTTP状态码405
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.NotAcceptable">
            <summary>
            客户端通过Accept头部表示不接受任何可用的资源表示形式，对应HTTP状态码406
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.ProxyAuthenticationRequired">
            <summary>
            请求的代理需要身份验证，Proxy-Authenticate头部包含身份验证细节，对应HTTP状态码407
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.RequestTimeout">
            <summary>
            客户端未在服务器预期的时间内发送请求，对应HTTP状态码408
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.Conflict">
            <summary>
            由于服务器上的冲突，请求无法执行，对应HTTP状态码409
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.Gone">
            <summary>
            请求的资源不再可用，对应HTTP状态码410
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.LengthRequired">
            <summary>
            缺少必需的Content-Length头部，对应HTTP状态码411
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.PreconditionFailed">
            <summary>
            请求设置的条件（如If-Match、If-None-Match等头部）失败，无法执行请求，对应HTTP状态码412
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.RequestEntityTooLarge">
            <summary>
            请求实体过大，服务器无法处理，对应HTTP状态码413
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.RequestUriTooLong">
            <summary>
            URI过长，对应HTTP状态码414
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.UnsupportedMediaType">
            <summary>
            请求的媒体类型不受支持，对应HTTP状态码415
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.RequestedRangeNotSatisfiable">
            <summary>
            请求的资源范围无法满足（如范围开始早于资源起点或结束晚于资源终点），对应HTTP状态码416
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.ExpectationFailed">
            <summary>
            Expect头部中给出的期望无法被服务器满足，对应HTTP状态码417
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.MisdirectedRequest">
            <summary>
            请求被定向到无法生成响应的服务器，对应HTTP状态码421
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.UnprocessableEntity">
            <summary>
            请求格式正确但因语义错误无法处理（与UnprocessableContent同义），对应HTTP状态码422
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.UnprocessableContent">
            <summary>
            请求格式正确但因语义错误无法处理（与UnprocessableEntity同义），对应HTTP状态码422
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.Locked">
            <summary>
            源或目标资源被锁定，对应HTTP状态码423
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.FailedDependency">
            <summary>
            由于依赖的操作失败，无法对资源执行请求的方法，对应HTTP状态码424
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.UpgradeRequired">
            <summary>
            客户端应切换到其他协议（如TLS/1.0），对应HTTP状态码426
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.PreconditionRequired">
            <summary>
            服务器要求请求为条件请求，对应HTTP状态码428
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.TooManyRequests">
            <summary>
            用户在给定时间内发送了过多请求，对应HTTP状态码429
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.RequestHeaderFieldsTooLarge">
            <summary>
            服务器因请求头部字段过大（单个或整体）而不愿处理请求，对应HTTP状态码431
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.UnavailableForLegalReasons">
            <summary>
            服务器因法律要求拒绝访问资源，对应HTTP状态码451
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.InternalServerError">
            <summary>
            服务器发生通用错误，对应HTTP状态码500
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.NotImplemented">
            <summary>
            服务器不支持请求的功能，对应HTTP状态码501
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.BadGateway">
            <summary>
            中间代理服务器从另一个代理或原始服务器收到错误响应，对应HTTP状态码502
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.ServiceUnavailable">
            <summary>
            服务器暂时不可用（通常因高负载或维护），对应HTTP状态码503
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.GatewayTimeout">
            <summary>
            中间代理服务器在等待另一个代理或原始服务器的响应时超时，对应HTTP状态码504
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.HttpVersionNotSupported">
            <summary>
            服务器不支持请求的HTTP版本，对应HTTP状态码505
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.VariantAlsoNegotiates">
            <summary>
            选择的变体资源配置为参与透明内容协商，因此不是协商过程的合适端点，对应HTTP状态码506
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.InsufficientStorage">
            <summary>
            服务器无法存储完成请求所需的表示，对应HTTP状态码507
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.LoopDetected">
            <summary>
            服务器在处理"Depth: infinity"的WebDAV请求时遇到无限循环，终止操作（用于向后兼容不识别208状态码的客户端），对应HTTP状态码508
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.NotExtended">
            <summary>
            服务器需要请求进行进一步扩展以完成处理，对应HTTP状态码510
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpStatusCode.NetworkAuthenticationRequired">
            <summary>
            客户端需要进行网络身份验证以获取网络访问（用于控制网络访问的拦截代理），对应HTTP状态码511
            </summary>
        </member>
        <member name="T:TouchSocket.Http.HttpTools">
            <summary>
            Http工具
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpTools.GetContentTypeFromExtension(System.String)">
            <summary>
            从扩展名获取ContentType
            </summary>
            <param name="extension"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.TouchSocketHttpUtility">
            <summary>
            TouchSocketHttp辅助工具类
            </summary>
        </member>
        <member name="F:TouchSocket.Http.TouchSocketHttpUtility.NoCacheMaxSize">
            <summary>
            非缓存上限
            </summary>
        </member>
        <member name="P:TouchSocket.Http.TouchSocketHttpUtility.CRLF">
            <summary>
            获取一个只读的字节序列，表示回车换行(CRLF)。
            </summary>
            <value>
            一个包含回车和换行字节的只读字节序列。
            </value>
        </member>
        <member name="M:TouchSocket.Http.TouchSocketHttpUtility.AppendAnd``1(``0@)">
            <summary>
            在 <see cref="T:TouchSocket.Core.IByteBlock"/> 中追加 "&amp;" 符号。
            </summary>
            <typeparam name="TByteBlock">实现了 <see cref="T:TouchSocket.Core.IByteBlock"/> 的类型。</typeparam>
            <param name="byteBlock">字节块实例。</param>
        </member>
        <member name="M:TouchSocket.Http.TouchSocketHttpUtility.AppendColon``1(``0@)">
            <summary>
            在 <see cref="T:TouchSocket.Core.IByteBlock"/> 中追加 ":" 符号。
            </summary>
            <typeparam name="TByteBlock">实现了 <see cref="T:TouchSocket.Core.IByteBlock"/> 的类型。</typeparam>
            <param name="byteBlock">字节块实例。</param>
        </member>
        <member name="M:TouchSocket.Http.TouchSocketHttpUtility.AppendEqual``1(``0@)">
            <summary>
            在 <see cref="T:TouchSocket.Core.IByteBlock"/> 中追加 "=" 符号。
            </summary>
            <typeparam name="TByteBlock">实现了 <see cref="T:TouchSocket.Core.IByteBlock"/> 的类型。</typeparam>
            <param name="byteBlock">字节块实例。</param>
        </member>
        <member name="M:TouchSocket.Http.TouchSocketHttpUtility.AppendHTTP``1(``0@)">
            <summary>
            在 <see cref="T:TouchSocket.Core.IByteBlock"/> 中追加 "HTTP" 字符串。
            </summary>
            <typeparam name="TByteBlock">实现了 <see cref="T:TouchSocket.Core.IByteBlock"/> 的类型。</typeparam>
            <param name="byteBlock">字节块实例。</param>
        </member>
        <member name="M:TouchSocket.Http.TouchSocketHttpUtility.AppendQuestionMark``1(``0@)">
            <summary>
            在 <see cref="T:TouchSocket.Core.IByteBlock"/> 中追加 "?" 符号。
            </summary>
            <typeparam name="TByteBlock">实现了 <see cref="T:TouchSocket.Core.IByteBlock"/> 的类型。</typeparam>
            <param name="byteBlock">字节块实例。</param>
        </member>
        <member name="M:TouchSocket.Http.TouchSocketHttpUtility.AppendRn``1(``0@)">
            <summary>
            在 <see cref="T:TouchSocket.Core.IByteBlock"/> 中追加回车换行符 "\r\n"。
            </summary>
            <typeparam name="TByteBlock">实现了 <see cref="T:TouchSocket.Core.IByteBlock"/> 的类型。</typeparam>
            <param name="byteBlock">字节块实例。</param>
        </member>
        <member name="M:TouchSocket.Http.TouchSocketHttpUtility.AppendSlash``1(``0@)">
            <summary>
            在 <see cref="T:TouchSocket.Core.IByteBlock"/> 中追加 "/" 符号。
            </summary>
            <typeparam name="TByteBlock">实现了 <see cref="T:TouchSocket.Core.IByteBlock"/> 的类型。</typeparam>
            <param name="byteBlock">字节块实例。</param>
        </member>
        <member name="M:TouchSocket.Http.TouchSocketHttpUtility.AppendSpace``1(``0@)">
            <summary>
            在 <see cref="T:TouchSocket.Core.IByteBlock"/> 中追加空格符。
            </summary>
            <typeparam name="TByteBlock">实现了 <see cref="T:TouchSocket.Core.IByteBlock"/> 的类型。</typeparam>
            <param name="byteBlock">字节块实例。</param>
        </member>
        <member name="M:TouchSocket.Http.TouchSocketHttpUtility.AppendUtf8String``1(``0@,System.String)">
            <summary>
            在 <see cref="T:TouchSocket.Core.IByteBlock"/> 中追加指定的 UTF-8 编码字符串。
            </summary>
            <typeparam name="TByteBlock">实现了 <see cref="T:TouchSocket.Core.IByteBlock"/> 的类型。</typeparam>
            <param name="byteBlock">字节块实例。</param>
            <param name="value">要追加的字符串。</param>
        </member>
        <member name="M:TouchSocket.Http.TouchSocketHttpUtility.AppendHex``1(``0@,System.Int32)">
            <summary>
            在 <see cref="T:TouchSocket.Core.IByteBlock"/> 中追加指定整数的十六进制表示。
            </summary>
            <typeparam name="TByteBlock">实现了 <see cref="T:TouchSocket.Core.IByteBlock"/> 的类型。</typeparam>
            <param name="byteBlock">字节块实例。</param>
            <param name="value">要追加的整数值。</param>
        </member>
        <member name="T:TouchSocket.Http.AuthenticationChallenge">
            <summary>
            处理代理认证凭证
            </summary>
        </member>
        <member name="M:TouchSocket.Http.AuthenticationChallenge.#ctor(System.String,TouchSocket.Http.NetworkCredential,System.UInt32)">
            <summary>
            构造
            </summary>
            <param name="value">服务器返回的凭证认证类型</param>
            <param name="credential">基本凭证用户名密码</param>
            <param name="nonceCount">暂时不知道是什么</param>
        </member>
        <member name="P:TouchSocket.Http.AuthenticationChallenge.NonceCount">
            <summary>
            暂时不知
            </summary>
        </member>
        <member name="P:TouchSocket.Http.AuthenticationChallenge.Parameters">
            <summary>
            其实用不用他都一样
            </summary>
        </member>
        <member name="P:TouchSocket.Http.AuthenticationChallenge.Type">
            <summary>
            凭证类型
            </summary>
        </member>
        <member name="M:TouchSocket.Http.AuthenticationChallenge.ToString">
            <summary>
            转换成凭证本文
            </summary>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="T:TouchSocket.Http.AuthenticationType">
            <summary>
            代理身份认证类型
            </summary>
        </member>
        <member name="F:TouchSocket.Http.AuthenticationType.None">
            <summary>
            不允许身份认证
            </summary>
        </member>
        <member name="F:TouchSocket.Http.AuthenticationType.Digest">
            <summary>
            指定摘要身份验证。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.AuthenticationType.Basic">
            <summary>
            指定基本身份验证。
            </summary>
        </member>
        <member name="F:TouchSocket.Http.AuthenticationType.Anonymous">
            <summary>
            指定匿名身份验证。
            </summary>
        </member>
        <member name="T:TouchSocket.Http.NetworkCredential">
            <summary>
            代理身份认证
            </summary>
        </member>
        <member name="M:TouchSocket.Http.NetworkCredential.#ctor(System.String,System.String,System.String,System.String[])">
            <summary>
            构造
            </summary>
            <param name="username"></param>
            <param name="password"></param>
            <param name="domain">基本认证应该不需要这个</param>
            <param name="roles"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="P:TouchSocket.Http.NetworkCredential.Username">
            <summary>
            凭证用户名
            </summary>
        </member>
        <member name="P:TouchSocket.Http.NetworkCredential.Password">
            <summary>
            凭证密码
            </summary>
        </member>
        <member name="P:TouchSocket.Http.NetworkCredential.Domain">
            <summary>
            Domain
            </summary>
        </member>
        <member name="P:TouchSocket.Http.NetworkCredential.Roles">
            <summary>
            Roles
            </summary>
        </member>
        <member name="T:TouchSocket.Http.HttpClient">
            <summary>
            Http客户端
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpClient.ConnectAsync(System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpClient.RequestAsync(TouchSocket.Http.HttpRequest,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpClient.RequestContentAsync(TouchSocket.Http.HttpRequest,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.HttpClientBase">
            <summary>
            Http客户端基类
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpClientBase.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpClientBase.SetWarpAdapter(TouchSocket.Core.SingleStreamDataHandlingAdapter)">
            <summary>
            设置用于处理单流数据的转换适配器
            </summary>
            <param name="adapter">要设置的SingleStreamDataHandlingAdapter实例</param>
        </member>
        <member name="M:TouchSocket.Http.HttpClientBase.ProtectedRequestAsync(TouchSocket.Http.HttpRequest,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步发送Http请求，并仅等待响应头
            </summary>
            <param name="request">要发送的HttpRequest对象</param>
            <param name="millisecondsTimeout">超时时间，单位为毫秒，默认为10秒</param>
            <param name="token">用于取消操作的CancellationToken</param>
            <returns>返回HttpResponseResult对象，包含响应结果和释放锁的方法</returns>
            <exception cref="T:System.TimeoutException">当操作超时时抛出</exception>
            <exception cref="T:System.OperationCanceledException">当操作被取消时抛出</exception>
            <exception cref="T:System.Exception">当发生其他异常时抛出</exception>
        </member>
        <member name="M:TouchSocket.Http.HttpClientBase.ProtectedRequestContentAsync(TouchSocket.Http.HttpRequest,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步发送Http请求，并等待全部响应
            </summary>
            <param name="request">Http请求对象</param>
            <param name="millisecondsTimeout">超时时间，单位为毫秒，默认为10秒</param>
            <param name="token">取消令牌</param>
            <returns>返回Http响应结果</returns>
            <exception cref="T:System.TimeoutException">当操作超时时抛出</exception>
            <exception cref="T:System.OperationCanceledException">当操作被取消时抛出</exception>
            <exception cref="T:System.Exception">当发生其他异常时抛出</exception>
        </member>
        <member name="M:TouchSocket.Http.HttpClientBase.OnTcpConnecting(TouchSocket.Sockets.ConnectingEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpClientBase.OnTcpClosed(TouchSocket.Sockets.ClosedEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpClientBase.OnTcpReceived(TouchSocket.Sockets.ReceivedDataEventArgs)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.HttpClientSlim">
            <summary>
            这是基于<see cref="T:System.Net.Http.HttpClient"/>的通讯模型。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpClientSlim.#ctor(System.Net.Http.HttpClient)">
            <summary>
            这是基于<see cref="T:System.Net.Http.HttpClient"/>的通讯模型。
            </summary>
            <param name="httpClient"></param>
        </member>
        <member name="P:TouchSocket.Http.HttpClientSlim.HttpClient">
            <summary>
            通讯客户端
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpClientSlim.LoadConfig(TouchSocket.Core.TouchSocketConfig)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.HttpService`1">
            <summary>
            HTTP/HTTPS服务器
            </summary>
        </member>
        <member name="T:TouchSocket.Http.HttpService">
            <summary>
            HTTP/HTTPS服务器
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpService.NewClient">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.HttpSessionClient">
            <summary>
            http辅助类
            </summary>
            <summary>
            http辅助类
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpSessionClient.#ctor">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpSessionClient.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpSessionClient.OnReceivedHttpRequest(TouchSocket.Http.HttpContext)">
            <summary>
            当收到到Http请求时。覆盖父类方法将不会触发插件。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpSessionClient.OnTcpClosed(TouchSocket.Sockets.ClosedEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpSessionClient.OnTcpConnecting(TouchSocket.Sockets.ConnectingEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpSessionClient.OnTcpReceived(TouchSocket.Sockets.ReceivedDataEventArgs)">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.HttpSessionClient.WebSocket">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpSessionClient.OnWebSocketHandshaking(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            在WebSocket握手过程中触发插件执行异步任务
            </summary>
            <param name="webSocket">WebSocket对象，用于进行WebSocket通信</param>
            <param name="e">HTTP上下文参数，提供关于HTTP请求和响应的信息</param>
            <returns>返回一个任务，该任务在插件处理完成后结束</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpSessionClient.OnWebSocketHandshaked(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            当WebSocket握手成功时，触发相关插件的异步事件。
            </summary>
            <param name="webSocket">WebSocket对象，表示握手成功的WebSocket连接。</param>
            <param name="e">HttpContextEventArgs对象，包含HTTP上下文信息。</param>
            <returns>一个表示事件处理完成的Task对象。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpSessionClient.OnWebSocketReceived(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.WebSockets.WSDataFrameEventArgs)">
            <summary>
            虚拟异步方法：当WebSocket接收到数据时触发
            </summary>
            <param name="webSocket">提供数据接收的WebSocket实例</param>
            <param name="e">包含接收数据的事件参数</param>
            <remarks>
            此方法通过调用插件管理器来通知所有实现了<see cref="T:TouchSocket.Http.WebSockets.IWebSocketReceivedPlugin"/>接口的插件，
            使它们能够处理接收到的WebSocket数据。这样做可以扩展数据处理逻辑，而无需直接修改此方法。
            </remarks>
        </member>
        <member name="M:TouchSocket.Http.HttpSessionClient.OnWebSocketClosing(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Sockets.ClosingEventArgs)">
            <summary>
            调用前触发WebSocket关闭时的插件
            </summary>
            <param name="webSocket">当前的WebSocket实例</param>
            <param name="e">关闭事件的参数</param>
            <returns>异步任务</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpSessionClient.OnWebSocketClosed(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Sockets.ClosedEventArgs)">
            <summary>
            虚拟异步方法：处理WebSocket关闭事件
            </summary>
            <param name="webSocket">关闭的WebSocket实例</param>
            <param name="e">WebSocket关闭事件的附加参数</param>
            <remarks>
            此方法通过调用插件管理器，触发IWebSocketClosedPlugin接口的实现来处理WebSocket关闭事件
            </remarks>
        </member>
        <member name="M:TouchSocket.Http.HttpSessionClient.SwitchProtocolToWebSocketAsync(TouchSocket.Http.HttpContext)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.IHttpClient">
            <summary>
            Http终端接口
            </summary>
        </member>
        <member name="M:TouchSocket.Http.IHttpClient.RequestAsync(TouchSocket.Http.HttpRequest,System.Int32,System.Threading.CancellationToken)">
            <summary>
            发起请求
            </summary>
            <param name="request">请求体</param>
            <param name="millisecondsTimeout">等待超时时间</param>
            <param name="token">结束等待令箭</param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.IHttpClient.RequestContentAsync(TouchSocket.Http.HttpRequest,System.Int32,System.Threading.CancellationToken)">
            <summary>
            发起请求，并获取数据体
            </summary>
            <param name="request">请求体</param>
            <param name="millisecondsTimeout">等待超时时间</param>
            <param name="token">结束等待令箭</param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.IHttpService`1">
            <summary>
            IHttpService
            </summary>
        </member>
        <member name="T:TouchSocket.Http.IHttpService">
            <summary>
            IHttpService
            </summary>
        </member>
        <member name="T:TouchSocket.Http.IHttpServiceBase">
            <summary>
            IHttpServiceBase
            </summary>
        </member>
        <member name="T:TouchSocket.Http.IHttpSession">
            <summary>
            Http终端基础接口
            </summary>
        </member>
        <member name="T:TouchSocket.Http.IHttpSessionClient">
            <summary>
            Http服务器终端接口
            </summary>
        </member>
        <member name="P:TouchSocket.Http.IHttpSessionClient.WebSocket">
            <summary>
            当该连接是WebSocket时，可获取该对象，否则为null。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.IHttpSessionClient.SwitchProtocolToWebSocketAsync(TouchSocket.Http.HttpContext)">
            <summary>
            转化Protocol协议标识为<see cref="F:TouchSocket.Sockets.Protocol.WebSocket"/>
            </summary>
            <param name="httpContext">Http上下文</param>
        </member>
        <member name="T:TouchSocket.Http.CorsBuilder">
            <summary>
            CorsBuilder
            </summary>
        </member>
        <member name="P:TouchSocket.Http.CorsBuilder.Credentials">
            <summary>
            允许客户端携带验证信息
            </summary>
        </member>
        <member name="P:TouchSocket.Http.CorsBuilder.Headers">
            <summary>
            请求头
            </summary>
        </member>
        <member name="P:TouchSocket.Http.CorsBuilder.Methods">
            <summary>
            允许跨域的方法。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.CorsBuilder.Origin">
            <summary>
            允许跨域的域名
            </summary>
        </member>
        <member name="M:TouchSocket.Http.CorsBuilder.AllowAnyHeaders">
            <summary>
            允许所有的Header
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.CorsBuilder.AllowAnyMethod">
            <summary>
            允许任何Method。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.CorsBuilder.AllowAnyOrigin">
            <summary>
            允许所有的源
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.CorsBuilder.AllowCredentials">
            <summary>
            允许客户端携带验证信息
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.CorsBuilder.WithHeaders(System.String[])">
            <summary>
            允许跨域的Header
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.CorsBuilder.WithMethods(System.String[])">
            <summary>
            允许跨域的方法。
            例如“PUT,POST,GET,DELETE,OPTIONS,HEAD,PATCH”
            </summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.CorsBuilder.WithOrigin(System.String)">
            <summary>
            允许跨域的域名
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.CorsBuilder.Build">
            <summary>
            构建
            </summary>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.CorsOptions">
            <summary>
            跨域相关配置
            </summary>
        </member>
        <member name="P:TouchSocket.Http.CorsOptions.CorsPolicys">
            <summary>
            跨域策略集
            </summary>
        </member>
        <member name="M:TouchSocket.Http.CorsOptions.Add(System.String,System.Action{TouchSocket.Http.CorsBuilder})">
            <summary>
            添加跨域策略
            </summary>
            <param name="policyName"></param>
            <param name="corsBuilderAction"></param>
        </member>
        <member name="M:TouchSocket.Http.CorsOptions.Add(System.String,TouchSocket.Http.CorsPolicy)">
            <summary>
            添加跨域策略
            </summary>
            <param name="policyName"></param>
            <param name="corsResult"></param>
        </member>
        <member name="T:TouchSocket.Http.CorsPlugin">
            <summary>
            可以配置跨域的插件
            </summary>
        </member>
        <member name="M:TouchSocket.Http.CorsPlugin.#ctor(TouchSocket.Http.ICorsService,System.String)">
            <summary>
            可以配置跨域的插件
            </summary>
            <param name="corsService"></param>
            <param name="policyName"></param>
        </member>
        <member name="M:TouchSocket.Http.CorsPlugin.OnHttpRequest(TouchSocket.Http.IHttpSessionClient,TouchSocket.Http.HttpContextEventArgs)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.CorsPolicy">
            <summary>
            表示跨域资源共享（CORS）策略。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.CorsPolicy.#ctor(System.Boolean,System.String,System.String,System.String)">
            <summary>
            初始化 <see cref="T:TouchSocket.Http.CorsPolicy"/> 类的新实例。
            </summary>
            <param name="credentials">是否允许客户端携带验证信息。</param>
            <param name="headers">允许的请求头。</param>
            <param name="methods">允许跨域的方法。</param>
            <param name="origin">允许跨域的域名。</param>
        </member>
        <member name="P:TouchSocket.Http.CorsPolicy.Credentials">
            <summary>
            获取一个值，该值指示是否允许客户端携带验证信息。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.CorsPolicy.Headers">
            <summary>
            获取允许的请求头。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.CorsPolicy.Methods">
            <summary>
            获取允许跨域的方法。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.CorsPolicy.Origin">
            <summary>
            获取允许跨域的域名。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.CorsPolicy.Apply(TouchSocket.Http.HttpContext)">
            <summary>
            应用跨域策略到指定的 HTTP 上下文。
            </summary>
            <param name="context">HTTP 上下文。</param>
        </member>
        <member name="T:TouchSocket.Http.ICorsService">
            <summary>
            跨域相关的服务类接口
            </summary>
        </member>
        <member name="M:TouchSocket.Http.ICorsService.GetPolicy(System.String)">
            <summary>
            按照策略名称，获取策略
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.HttpClientDataHandlingAdapter">
            <summary>
            Http客户端数据处理适配器
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpClientDataHandlingAdapter.CanSplicingSend">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpClientDataHandlingAdapter.OnLoaded(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpClientDataHandlingAdapter.PreviewReceivedAsync(TouchSocket.Core.ByteBlock)">
            <inheritdoc/>
            <param name="byteBlock"></param>
        </member>
        <member name="T:TouchSocket.Http.HttpServerDataHandlingAdapter">
            <summary>
            Http服务器数据处理适配器
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpServerDataHandlingAdapter.CanSplicingSend">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpServerDataHandlingAdapter.OnLoaded(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpServerDataHandlingAdapter.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.HttpServerDataHandlingAdapter.PreviewReceivedAsync(TouchSocket.Core.ByteBlock)">
            <inheritdoc/>
            <param name="byteBlock"></param>
        </member>
        <member name="T:TouchSocket.Http.HttpContextEventHandler`1">
            <summary>
            HTTP上下文事件委托
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocket.Http.HttpContextEventArgs">
            <summary>
            Http请求事件类
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpContextEventArgs.Context">
            <summary>
            Http上下文
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpContextEventArgs.#ctor(TouchSocket.Http.HttpContext)">
            <summary>
            构造函数
            </summary>
            <param name="context"></param>
        </member>
        <member name="T:TouchSocket.Http.HttpClientExtension">
            <summary>
            HttpClient 扩展类
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpClientExtension.GetByteArrayAsync(TouchSocket.Http.IHttpClient,System.String,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步获取URL的字节数组表示形式。
            </summary>
            <param name="httpClient">发起HTTP请求的客户端。</param>
            <param name="url">要请求的URL。</param>
            <param name="millisecondsTimeout">请求超时时间，以毫秒为单位，默认为10秒。</param>
            <param name="token">用于取消操作的取消令牌。</param>
            <returns>包含从URL获取的字节的数组。</returns>
            <exception cref="T:System.Exception">如果HTTP请求失败，将抛出异常。</exception>
        </member>
        <member name="M:TouchSocket.Http.HttpClientExtension.GetStringAsync(TouchSocket.Http.IHttpClient,System.String,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步获取指定URL的字符串内容。
            </summary>
            <param name="httpClient">用于发送HTTP请求的客户端。</param>
            <param name="url">要请求的URL。</param>
            <param name="millisecondsTimeout">请求超时时间，以毫秒为单位，默认为10秒。</param>
            <param name="token">用于取消操作的取消令牌。</param>
            <returns>返回从指定URL获取的字符串。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpClientExtension.GetFileAsync(TouchSocket.Http.IHttpClient,TouchSocket.Http.HttpRequest,System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步获取HTTP请求的文件内容
            </summary>
            <param name="httpClient">HTTP客户端接口</param>
            <param name="request">HTTP请求对象</param>
            <param name="stream">用于存储文件内容的目标流</param>
            <param name="millisecondsTimeout">请求超时时间，以毫秒为单位，默认为10秒</param>
            <param name="token">用于取消操作的取消令牌</param>
            <returns>返回一个异步任务</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpClientExtension.GetFileAsync(TouchSocket.Http.IHttpClient,TouchSocket.Http.HttpRequest,System.IO.Stream,TouchSocket.Http.HttpFlowOperator)">
            <summary>
            异步获取HTTP请求的文件内容
            </summary>
            <param name="httpClient">HTTP客户端接口</param>
            <param name="request">HTTP请求对象</param>
            <param name="stream">用于存储文件内容的目标流</param>
            <param name="flowOperator">用于控制下载过程的操作符。</param>
            <returns>返回一个Result对象，表示下载结果。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpClientExtension.GetFileAsync(TouchSocket.Http.IHttpClient,System.String,System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步获取URL指定的文件，并将其内容写入提供的流中。
            </summary>
            <param name="httpClient">用于发送HTTP请求的客户端。</param>
            <param name="url">要获取的文件的URL。</param>
            <param name="stream">将文件内容写入的流。</param>
            <param name="millisecondsTimeout">操作超时时间，以毫秒为单位，默认为10秒。</param>
            <param name="token">用于取消异步操作的取消令牌。</param>
            <returns>返回一个Task对象，表示异步操作。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpClientExtension.GetFileAsync(TouchSocket.Http.IHttpClient,System.String,System.IO.Stream,TouchSocket.Http.HttpFlowOperator)">
            <summary>
            异步获取URL指定的文件，并将其内容写入提供的流中。
            </summary>
            <param name="httpClient">用于发送HTTP请求的客户端。</param>
            <param name="url">要获取的文件的URL。</param>
            <param name="stream">将文件内容写入的流。</param>
            <param name="flowOperator">用于控制下载过程的操作符。</param>
            <returns>返回一个Result对象，表示下载结果。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpClientExtension.UploadFileAsync``1(``0,System.String,System.IO.FileInfo,System.Int32,System.Threading.CancellationToken)">
            <summary>
            异步上传文件到指定URL。
            </summary>
            <param name="client">HttpClient实例，用于发送HTTP请求。</param>
            <param name="url">文件上传的URL地址。</param>
            <param name="fileInfo">包含文件信息的FileInfo对象，用于获取文件内容和属性。</param>
            <param name="millisecondsTimeout">请求的超时时间，默认为10秒。如果在此时间内未完成上传，请求将被取消。</param>
            <param name="token">用于取消操作的取消令牌。</param>
            <typeparam name="TClient">客户端类型，必须继承自HttpClientBase并实现IHttpClient接口。</typeparam>
        </member>
        <member name="M:TouchSocket.Http.HttpClientExtension.UploadFileAsync``1(``0,TouchSocket.Http.HttpRequest,System.IO.Stream,TouchSocket.Http.HttpFlowOperator)">
            <summary>
            异步上传文件到指定的URL。
            </summary>
            <typeparam name="TClient">客户端类型，必须继承自HttpClientBase并实现IHttpClient接口。</typeparam>
            <param name="client">HttpClient实例，用于发送HTTP请求。</param>
            <param name="request">HTTP请求对象。</param>
            <param name="stream">包含文件内容的流。</param>
            <param name="flowOperator">用于控制上传过程的操作符。</param>
            <returns>返回一个Result对象，表示上传结果。</returns>
        </member>
        <member name="T:TouchSocket.Http.HttpContainerExtension">
            <summary>
            HttpContainerExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpContainerExtension.AddCors(TouchSocket.Core.IRegistrator,System.Action{TouchSocket.Http.CorsOptions})">
            <summary>
            向注册器中添加跨域服务。
            </summary>
            <param name="registrator"></param>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.HttpExtensions">
            <summary>
            Http扩展辅助
            </summary>
        </member>
        <member name="F:TouchSocket.Http.HttpExtensions.MultipartFormData">
            <summary>
            表示 multipart/form-data 内容类型的常量字符串。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.AddHeader``1(``0,System.String,System.String)">
            <summary>
            添加Header参数
            </summary>
            <param name="request"></param>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.GetBody(TouchSocket.Http.HttpBase)">
            <summary>
            获取Body的字符串
            </summary>
            <param name="httpBase"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.GetBodyAsync(TouchSocket.Http.HttpBase,System.Text.Encoding,System.Threading.CancellationToken)">
            <summary>
            异步获取 HTTP 请求的主体内容。
            </summary>
            <param name="httpBase">HttpBase 实例，用于发起 HTTP 请求。</param>
            <param name="encoding">编码格式</param>
            <param name="token">可取消令箭</param>
            <returns>返回主体内容的字符串表示，如果内容为空则返回 null。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.GetBodyAsync(TouchSocket.Http.HttpBase,System.Threading.CancellationToken)">
            <summary>
            异步获取utf8编码的 HTTP 请求的主体内容。
            </summary>
            <param name="httpBase">HttpBase 实例，用于发起 HTTP 请求。</param>
            <param name="token">可取消令箭</param>
            <returns>返回主体内容的字符串表示，如果内容为空则返回 null。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.GetBoundary(TouchSocket.Http.HttpBase)">
            <summary>
            当数据类型为multipart/form-data时，获取boundary
            </summary>
            <param name="httpBase"></param>
            <returns></returns>
            <exception cref="T:System.Exception"></exception>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.GetContent(TouchSocket.Http.HttpBase,System.Threading.CancellationToken)">
            <summary>
            同步获取一次性内容。
            </summary>
            <returns>返回一个只读内存块，该内存块包含具体的字节内容。</returns>
            <param name="httpBase"></param>
            <param name="cancellationToken">一个CancellationToken对象，用于取消异步操作。</param>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.FromJson``1(``0,System.String)">
            <summary>
            从Json
            </summary>
            <param name="request"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.FromText``1(``0,System.String)">
            <summary>
            从文本
            </summary>
            <param name="request"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.FromXml``1(``0,System.String)">
            <summary>
            从Xml格式
            </summary>
            <param name="request"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.FromXML``1(``0,System.String)">
            <summary>
            从Xml格式
            </summary>
            <typeparam name="T"></typeparam>
            <param name="request"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetContent``1(``0,TouchSocket.Http.HttpContent)">
            <summary>
            为HttpBase类型对象设置内容。
            </summary>
            <typeparam name="T">泛型参数T，表示HttpBase类型或其派生类型。</typeparam>
            <param name="httpBase">需要设置内容的HttpBase类型对象。</param>
            <param name="content">要设置的内容，类型为HttpContent。</param>
            <returns>返回设置内容后的HttpBase对象。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetContent``1(``0,System.String,System.Text.Encoding)">
            <summary>
            设置内容
            </summary>
            <param name="httpBase">HttpBase类型的对象，其内容需要被设置</param>
            <param name="content">要设置的内容，以字符串形式传入</param>
            <param name="encoding">内容的编码方式，如果未指定，则默认使用UTF-8编码</param>
            <returns>返回设置后的内容对象，允许进行方法链调用</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetContentLength``1(``0,System.Int64)">
            <summary>
            设置数据体长度
            </summary>
            <param name="httpBase">要设置数据体长度的HttpBase对象</param>
            <param name="value">数据体的长度</param>
            <returns>返回修改后的HttpBase对象</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetContentTypeByExtension``1(``0,System.String)">
            <summary>
            从扩展名设置内容类型，必须以“.”开头
            </summary>
            <param name="httpBase">要设置内容类型的 HttpBase 对象</param>
            <param name="extension">文件扩展名，必须以“.”开头，用于确定内容类型</param>
            <returns>返回设置后的 HttpBase 对象</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetUrl``1(``0,System.String)">
            <summary>
            设置Url，可带参数
            </summary>
            <param name="request"></param>
            <param name="url">要设置的URL地址</param>
            <returns>返回当前HttpRequest实例，支持链式调用</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.AddQuery``1(``0,System.String,System.String)">
            <summary>
            添加Query参数
            </summary>
            <param name="request">请求对象</param>
            <param name="key">参数键</param>
            <param name="value">参数值</param>
            <returns>返回添加了参数的请求对象</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.GetFormCollectionAsync``1(``0)">
            <summary>
            异步获取HttpRequest的表单集合
            </summary>
            <param name="request">HttpRequest对象，用于提取表单数据</param>
            <typeparam name="TRequest">泛型参数，限定为HttpRequest类型</typeparam>
            <returns>返回一个任务，该任务的结果是IFormCollection类型的表单集合</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.GetMultifileCollection``1(``0)">
            <summary>
            获取多文件集合。如果不存在，则返回null。
            </summary>
            <typeparam name="TRequest">请求类型，必须继承自HttpRequest。</typeparam>
            <param name="request">请求对象，用于提取多文件集合。</param>
            <returns>多文件集合对象，如果请求中不存在多文件数据，则返回null。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.InitHeaders``1(``0)">
            <summary>
            初始化常规的请求头。
            <para>包含：</para>
            <list type="number">
            <item>Connection:keep-alive</item>
            <item>Pragma:no-cache</item>
            <item>UserAgent:TouchSocket.Http</item>
            </list>
            </summary>
            <param name="request">要初始化请求头的请求对象。</param>
            <returns>返回初始化后的请求对象。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetFormUrlEncodedContent``1(``0,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            将一个键值对集合按照application/x-www-form-urlencoded格式设置到HttpRequest的内容中
            </summary>
            <param name="request">待设置内容的HttpRequest对象</param>
            <param name="nameValueCollection">包含键值对的集合，将被转换为查询字符串格式</param>
            <typeparam name="TRequest">HttpRequest的类型，使用泛型以支持所有HttpRequest的子类</typeparam>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetHost``1(``0,System.String)">
            <summary>
            添加Host请求头
            </summary>
            <param name="request">要添加Host请求头的HttpRequest对象</param>
            <param name="host">要设置的Host值</param>
            <returns>返回修改后的HttpRequest对象</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.UrlEquals``1(``0,System.String)">
            <summary>
            对比不包含参数的Url。其中有任意一方为null，则均返回False。
            </summary>
            <param name="request">请求对象，用于获取待对比的相对URL。</param>
            <param name="url">待对比的目标URL字符串。</param>
            <returns>如果两个URL都不为null且在忽略大小写的情况下相等，则返回true；否则返回false。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.AsDelete``1(``0)">
            <summary>
            将请求对象的方法设置为Delete。
            </summary>
            <param name="request">要设置为Delete方法的请求对象。</param>
            <returns>返回修改过方法类型的请求对象。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.AsGet``1(``0)">
            <summary>
            将请求方法设置为Get
            </summary>
            <param name="request">要转换为Get方法的请求对象</param>
            <returns>修改过方法的请求对象</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.AsMethod``1(``0,System.String)">
            <summary>
            将指定的请求对象设置为指定的HTTP方法。
            该方法扩展了HttpRequest类，允许在调用时动态改变请求的方法类型。
            </summary>
            <param name="request">要修改的HttpRequest对象。</param>
            <param name="method">要设置的HTTP方法，如"Get"、"Post"等。</param>
            <returns>修改后的HttpRequest对象。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.AsPost``1(``0)">
            <summary>
            将请求对象设置为Post方法
            </summary>
            <param name="request">要设置为Post方法的请求对象</param>
            <returns>修改过方法类型的请求对象</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.AsPut``1(``0)">
            <summary>
            将请求对象的方法设置为PUT
            </summary>
            <param name="request">要修改的请求对象</param>
            <returns>修改后的请求对象</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.IsDelete``1(``0)">
            <summary>
            判断当前请求是否为Delete操作
            </summary>
            <param name="request">请求对象，用于检查请求方法</param>
            <returns>如果请求方法为Delete，则返回true；否则返回false</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.IsGet``1(``0)">
            <summary>
            判断当前请求是否为Get请求
            </summary>
            <param name="request">请求对象，用于检查其请求方法</param>
            <returns>如果请求方法是Get，则返回true；否则返回false</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.IsMethod``1(``0,System.String)">
            <summary>
            判断指定的请求是否为指定的HTTP方法类型
            </summary>
            <param name="request">待检查的HTTP请求</param>
            <param name="method">要判断的HTTP方法类型，如"Get"、"Post"</param>
            <returns>如果请求的方法类型与指定的方法一致，则返回true；否则返回false</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.IsPost``1(``0)">
            <summary>
            判断当前请求是否为Post请求
            </summary>
            <param name="request">请求对象，泛型参数，必须是HttpRequest的子类或实现</param>
            <returns>如果当前请求方法是Post，则返回true；否则返回false</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.IsPut``1(``0)">
            <summary>
            判断请求是否为PUT方法
            </summary>
            <param name="request">请求对象，类型为HttpRequest的泛型实例</param>
            <returns>如果请求方法为PUT，则返回true；否则返回false</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.IsAcceptGzip``1(``0)">
            <summary>
            判断请求是否接受Gzip压缩。
            </summary>
            <param name="request">请求对象，用于获取请求的接受编码。</param>
            <returns>如果请求接受Gzip压缩，则返回true；否则返回false。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.IsUpgrade``1(``0)">
            <summary>
            判断请求头中是否包含升级连接
            </summary>
            <param name="request">请求对象，泛型参数，要求是HttpRequest的子类或实现</param>
            <returns>如果请求头中包含升级连接，则返回true；否则返回false</returns>
        </member>
        <member name="F:TouchSocket.Http.HttpExtensions.HttpHeadersServer">
            <summary>
            表示 HTTP 头部的服务器信息。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.FromHtml``1(``0,System.String)">
            <summary>
            设置HTML内容。
            </summary>
            <typeparam name="TResponse">响应类型，必须继承自HttpResponse。</typeparam>
            <param name="response">响应对象，用于设置HTML内容。</param>
            <param name="htmlString">HTML字符串，表示要设置的内容。</param>
            <returns>返回设置了HTML内容的响应对象。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.IsSuccess``1(``0,System.Nullable{System.Int32})">
            <summary>
            判断返回的状态码是否为成功。
            </summary>
            <param name="response">要判断的响应对象。</param>
            <param name="status">
            可选参数，指定期望的状态码。
            当不指定具体的状态码时，只要状态码在200-299之间则为<see langword="true"/>。
            当指定时，状态码不仅必须要在200-299之间，还必须是指定的状态码才会返回<see langword="true"/>。
            </param>
            <returns>返回一个布尔值，表示响应状态码是否表示成功。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetContentTypeFromFileName``1(``0,System.String)">
            <summary>
            设置文件类型。
            </summary>
            <param name="response">要设置的HTTP响应对象。</param>
            <param name="fileName">文件名，用于确定Content-Type和文件下载时的提示名称。</param>
            <returns>返回设置后的HTTP响应对象。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetGzipContent``1(``0,System.Byte[])">
            <summary>
            为指定的HttpResponse对象设置Gzip压缩内容
            </summary>
            <typeparam name="TResponse">HttpResponse的类型</typeparam>
            <param name="response">要设置内容的HttpResponse对象</param>
            <param name="gzipContent">要设置的Gzip压缩内容</param>
            <returns>返回设置了Gzip内容的HttpResponse对象</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetRedirect``1(``0,System.String)">
            <summary>
             设置重定向响应。
             <para>
             默认状态码为302，状态信息为"Found"。如果需要自定义状态码和状态信息，请使用<see cref="M:TouchSocket.Http.HttpExtensions.SetStatus``1(``0,System.Int32,System.String)"/>方法。
             </para>
             </summary>
             <typeparam name="TResponse">响应类型，必须继承自HttpResponse。</typeparam>
             <param name="response">响应对象，用于设置重定向。</param>
             <param name="url">重定向的目标URL。</param>
             <returns>返回设置了重定向的响应对象。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetStatus``1(``0,System.Int32,System.String)">
            <summary>
            设置状态，并且附带时间戳。
            </summary>
            <param name="response">要设置状态的HttpResponse对象。</param>
            <param name="status">HTTP响应状态码。</param>
            <param name="msg">状态描述信息。</param>
            <returns>返回修改后的HttpResponse对象。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetStatus``1(``0)">
            <summary>
            设置默认Success状态，并且附带时间戳。
            </summary>
            <typeparam name="TResponse">泛型参数，表示HttpResponse的类型。</typeparam>
            <param name="response">要设置状态的HttpResponse对象。</param>
            <returns>返回设置后的HttpResponse对象。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.SetStatusWithSuccess``1(``0)">
            <summary>
            设置默认Success状态，并且附带时间戳。
            </summary>
            <typeparam name="TResponse">泛型参数，表示HttpResponse的类型。</typeparam>
            <param name="response">要设置状态的HttpResponse对象。</param>
            <returns>返回设置后的HttpResponse对象。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.UrlNotFind``1(``0)">
            <summary>
            设置HTTP响应为404 Not Found
            此方法用于处理路径文件未找到的情况，它将HTTP响应的状态码设置为404，并在响应体中返回一个简单的HTML页面，指示文件未找到。
            </summary>
            <param name="response">要设置的HTTP响应对象</param>
            <returns>设置后的HTTP响应对象</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.FromFileAsync(TouchSocket.Http.HttpResponse,System.IO.FileInfo,TouchSocket.Http.HttpFlowOperator,TouchSocket.Http.HttpRequest,System.String,System.Boolean)">
            <summary>
            从文件响应。
            <para>当response支持持续写入时，会直接回复响应。并阻塞执行，直到完成。所以在执行该方法之前，请确保已设置完成所有状态字</para>
            <para>当response不支持持续写入时，会填充Content，且不会响应，需要自己执行Build，并发送。</para>
            </summary>
            <param name="response">响应</param>
            <param name="request">请求头，用于尝试续传，为null时则不续传。</param>
            <param name="fileInfo">文件信息</param>
            <param name="flowOperator">流速控制</param>
            <param name="fileName">文件名，不设置时会获取路径文件名</param>
            <param name="autoGzip">是否自动<see cref="T:TouchSocket.Http.HttpRequest"/>请求，自动启用gzip</param>
            <exception cref="T:System.Exception"></exception>
            <exception cref="T:System.Exception"></exception>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.FromFileAsync(TouchSocket.Http.HttpResponse,System.IO.FileInfo,TouchSocket.Http.HttpRequest,System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
             从文件响应。
             <para>当response支持持续写入时，会直接回复响应。并阻塞执行，直到完成。所以在执行该方法之前，请确保已设置完成所有状态字</para>
             <para>当response不支持持续写入时，会填充Content，且不会响应，需要自己执行Build，并发送。</para>
             </summary>
             <param name="response">响应</param>
             <param name="fileInfo">文件信息</param>
             <param name="request">请求头，用于尝试续传，为null时则不续传。</param>
             <param name="fileName">文件名，不设置时会获取路径文件名</param>
             <param name="maxSpeed">最大速度。</param>
             <param name="bufferLen">读取长度。</param>
             <param name="autoGzip">是否自动<see cref="T:TouchSocket.Http.HttpRequest"/>请求，自动启用GZip</param>
             <exception cref="T:System.Exception"></exception>
             <returns>异步任务</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.FromFileAsync(TouchSocket.Http.HttpContext,System.IO.FileInfo,System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            从文件响应。
            <para>当response支持持续写入时，会直接回复响应。并阻塞执行，直到完成。所以在执行该方法之前，请确保已设置完成所有状态字</para>
            <para>当response不支持持续写入时，会填充Content，且不会响应，需要自己执行Build，并发送。</para>
            </summary>
            <param name="context">上下文</param>
            <param name="fileInfo">文件信息</param>
            <param name="fileName">文件名，不设置时会获取路径文件名</param>
            <param name="maxSpeed">最大速度。</param>
            <param name="bufferLen">读取长度。</param>
            <param name="autoGzip">是否自动<see cref="T:TouchSocket.Http.HttpRequest"/>请求，自动启用gzip</param>
            <exception cref="T:System.Exception"></exception>
            <exception cref="T:System.Exception"></exception>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpExtensions.CreateWriteStream``1(``0)">
            <summary>
            为指定的 HTTP 响应创建一个写入流。
            </summary>
            <param name="response">要关联写入流的 HTTP 响应对象。</param>
            <returns>一个 <see cref="T:System.IO.Stream"/> 对象，用于向 HTTP 响应写入数据。</returns>
            <remarks>
            此方法提供了一种方便的方式来获取一个写入流，该流可以直接与指定的 HTTP 响应对象关联，
            从而简化了向 HTTP 响应写入数据的过程。
            </remarks>
            <typeparam name="TResponse">HTTP 响应的类型，必须是 <see cref="T:TouchSocket.Http.HttpResponse"/> 的一个子类。</typeparam>
        </member>
        <member name="T:TouchSocket.Http.HttpFlowOperator">
            <summary>
            表示一个管理数据流的HTTP流操作器。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpFlowOperator.BlockSize">
            <summary>
            分块大小，默认64KB。
            </summary>
        </member>
        <member name="T:TouchSocket.Http.HttpContent">
            <summary>
            表示HTTP响应的内容部分，是一个抽象类
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpContent.InternalBuildingContent``1(``0@)">
            <summary>
            内部方法，用于构建HTTP响应的内容
            </summary>
            <typeparam name="TByteBlock">实现IByteBlock接口的类型</typeparam>
            <param name="byteBlock">字节块的引用</param>
            <returns>返回一个布尔值，表示构建内容是否成功</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpContent.InternalBuildingHeader(TouchSocket.Http.IHttpHeader)">
            <summary>
            内部方法，用于构建HTTP头
            </summary>
            <param name="header">HTTP头的接口实现</param>
        </member>
        <member name="M:TouchSocket.Http.HttpContent.InternalWriteContent(System.Func{System.ReadOnlyMemory{System.Byte},System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
            内部方法，用于写入HTTP响应内容
            </summary>
            <param name="func">一个函数，用于处理字节块的写入操作</param>
            <param name="token">用于取消操作的令牌</param>
            <returns>返回一个任务对象，代表异步写入操作</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpContent.OnBuildingContent``1(``0@)">
            <summary>
            抽象方法，由子类实现，用于构建HTTP响应的内容
            </summary>
            <typeparam name="TByteBlock">实现IByteBlock接口的类型</typeparam>
            <param name="byteBlock">字节块的引用</param>
            <returns>返回一个布尔值，表示构建内容是否成功</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpContent.OnBuildingHeader(TouchSocket.Http.IHttpHeader)">
            <summary>
            抽象方法，由子类实现，用于构建HTTP头
            </summary>
            <param name="header">HTTP头的接口实现</param>
        </member>
        <member name="M:TouchSocket.Http.HttpContent.TryComputeLength(System.Int64@)">
            <summary>
            尝试计算内容的长度。
            </summary>
            <param name="length">输出参数，表示内容的长度。</param>
            <returns>如果成功计算长度，则返回 true；否则返回 false。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpContent.WriteContent(System.Func{System.ReadOnlyMemory{System.Byte},System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
            抽象方法，由子类实现，用于写入HTTP响应内容
            </summary>
            <param name="writeFunc">一个函数，用于处理字节块的写入操作</param>
            <param name="token">用于取消操作的令牌</param>
            <returns>返回一个任务对象，代表异步写入操作</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpContent.op_Implicit(System.String)~TouchSocket.Http.HttpContent">
            <summary>
            将字符串内容隐式转换为HttpContent对象，使用UTF-8编码。
            </summary>
            <param name="content">要转换的字符串内容。</param>
            <returns>一个新的StringHttpContent对象。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpContent.op_Implicit(System.ReadOnlyMemory{System.Byte})~TouchSocket.Http.HttpContent">
            <summary>
            将只读内存字节内容隐式转换为HttpContent对象。
            </summary>
            <param name="content">要转换的只读内存字节内容。</param>
            <returns>一个新的ReadonlyMemoryHttpContent对象。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpContent.op_Implicit(System.Byte[])~TouchSocket.Http.HttpContent">
            <summary>
            将字节数组内容隐式转换为HttpContent对象。
            </summary>
            <param name="content">要转换的字节数组内容。</param>
            <returns>一个新的ReadonlyMemoryHttpContent对象。</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpContent.op_Implicit(System.IO.Stream)~TouchSocket.Http.HttpContent">
            <summary>
            将流内容隐式转换为HttpContent对象。
            </summary>
            <param name="content">要转换的流内容。</param>
            <returns>一个新的StreamHttpContent对象。</returns>
        </member>
        <member name="T:TouchSocket.Http.ReadonlyMemoryHttpContent">
            <summary>
            只读内存级别的Http内容。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.ReadonlyMemoryHttpContent.#ctor(System.ReadOnlyMemory{System.Byte},System.String)">
            <summary>
            初始化 <see cref="T:TouchSocket.Http.ReadonlyMemoryHttpContent"/> 类的新实例。
            </summary>
            <param name="memory">要封装的只读内存。</param>
            <param name="contentType">内容类型</param>
        </member>
        <member name="P:TouchSocket.Http.ReadonlyMemoryHttpContent.Memory">
            <summary>
            获取封装的只读内存。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.ReadonlyMemoryHttpContent.OnBuildingContent``1(``0@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.ReadonlyMemoryHttpContent.OnBuildingHeader(TouchSocket.Http.IHttpHeader)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.ReadonlyMemoryHttpContent.WriteContent(System.Func{System.ReadOnlyMemory{System.Byte},System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.ReadonlyMemoryHttpContent.TryComputeLength(System.Int64@)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.StreamHttpContent">
            <summary>
            继承自HttpContent的类，用于将Stream数据转换为可发送的HTTP内容。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.StreamHttpContent.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            初始化StreamHttpContent类的新实例。
            </summary>
            <param name="stream">要包装的流。</param>
            <param name="bufferLength">读取数据时使用的缓冲区长度，默认为64KB。</param>
        </member>
        <member name="M:TouchSocket.Http.StreamHttpContent.#ctor(System.IO.Stream,TouchSocket.Http.HttpFlowOperator,System.Int32)">
            <summary>
            初始化StreamHttpContent类的新实例。
            </summary>
            <param name="stream">要包装的流。</param>
            <param name="flowOperator">用于控制流操作的HttpFlowOperator实例。</param>
            <param name="bufferLength">读取数据时使用的缓冲区长度，默认为64KB。</param>
        </member>
        <member name="M:TouchSocket.Http.StreamHttpContent.#ctor(System.IO.Stream,TouchSocket.Http.HttpFlowOperator)">
            <summary>
            初始化StreamHttpContent类的新实例。
            </summary>
            <param name="stream">要包装的流。</param>
            <param name="flowOperator">用于控制流操作的HttpFlowOperator实例。</param>
        </member>
        <member name="P:TouchSocket.Http.StreamHttpContent.IsChunk">
            <summary>
            使用Chunk
            </summary>
        </member>
        <member name="M:TouchSocket.Http.StreamHttpContent.OnBuildingContent``1(``0@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.StreamHttpContent.OnBuildingHeader(TouchSocket.Http.IHttpHeader)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.StreamHttpContent.TryComputeLength(System.Int64@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.StreamHttpContent.WriteContent(System.Func{System.ReadOnlyMemory{System.Byte},System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.StringHttpContent">
            <summary>
            表示以字符串形式存储的 HTTP 内容。
            </summary>
            <remarks>
            该类继承自 ReadonlyMemoryHttpContent，用于处理只读的内存中 HTTP 内容。
            它将字符串内容转换为字节数组，并传递给基类以进行处理。
            </remarks>
        </member>
        <member name="M:TouchSocket.Http.StringHttpContent.#ctor(System.String,System.Text.Encoding,System.String)">
            <summary>
            初始化 StringHttpContent 类的新实例。
            </summary>
            <param name="content">要包含的字符串内容。</param>
            <param name="encoding">用于将字符串内容编码为字节数组的编码方式。</param>
            <param name="contentType">内容类型</param>
        </member>
        <member name="M:TouchSocket.Http.StringHttpContent.FromJson(System.String,System.Text.Encoding)">
            <summary>
            从 JSON 字符串创建 <see cref="T:TouchSocket.Http.StringHttpContent"/> 实例。
            </summary>
            <param name="json">JSON 字符串。</param>
            <param name="encoding">用于编码的字符集。</param>
            <returns>返回一个 <see cref="T:TouchSocket.Http.StringHttpContent"/> 实例。</returns>
        </member>
        <member name="M:TouchSocket.Http.StringHttpContent.FromJson(System.String)">
            <summary>
            从 JSON 字符串创建 <see cref="T:TouchSocket.Http.StringHttpContent"/> 实例，使用 UTF-8 编码。
            </summary>
            <param name="json">JSON 字符串。</param>
            <returns>返回一个 <see cref="T:TouchSocket.Http.StringHttpContent"/> 实例。</returns>
        </member>
        <member name="M:TouchSocket.Http.StringHttpContent.FromXml(System.String,System.Text.Encoding)">
            <summary>
            从 XML 字符串创建 <see cref="T:TouchSocket.Http.StringHttpContent"/> 实例。
            </summary>
            <param name="xml">XML 字符串。</param>
            <param name="encoding">用于编码的字符集。</param>
            <returns>返回一个 <see cref="T:TouchSocket.Http.StringHttpContent"/> 实例。</returns>
        </member>
        <member name="M:TouchSocket.Http.StringHttpContent.FromXml(System.String)">
            <summary>
            从 XML 字符串创建 <see cref="T:TouchSocket.Http.StringHttpContent"/> 实例，使用 UTF-8 编码。
            </summary>
            <param name="xml">XML 字符串。</param>
            <returns>返回一个 <see cref="T:TouchSocket.Http.StringHttpContent"/> 实例。</returns>
        </member>
        <member name="M:TouchSocket.Http.StringHttpContent.FromHtml(System.String,System.Text.Encoding)">
            <summary>
            从 HTML 字符串创建 <see cref="T:TouchSocket.Http.StringHttpContent"/> 实例。
            </summary>
            <param name="html">HTML 字符串。</param>
            <param name="encoding">用于编码的字符集。</param>
            <returns>返回一个 <see cref="T:TouchSocket.Http.StringHttpContent"/> 实例。</returns>
        </member>
        <member name="M:TouchSocket.Http.StringHttpContent.FromHtml(System.String)">
            <summary>
            从 HTML 字符串创建 <see cref="T:TouchSocket.Http.StringHttpContent"/> 实例，使用 UTF-8 编码。
            </summary>
            <param name="html">HTML 字符串。</param>
            <returns>返回一个 <see cref="T:TouchSocket.Http.StringHttpContent"/> 实例。</returns>
        </member>
        <member name="M:TouchSocket.Http.StringHttpContent.FromText(System.String,System.Text.Encoding)">
            <summary>
            从纯文本字符串创建 <see cref="T:TouchSocket.Http.StringHttpContent"/> 实例。
            </summary>
            <param name="text">纯文本字符串。</param>
            <param name="encoding">用于编码的字符集。</param>
            <returns>返回一个 <see cref="T:TouchSocket.Http.StringHttpContent"/> 实例。</returns>
        </member>
        <member name="M:TouchSocket.Http.StringHttpContent.FromText(System.String)">
            <summary>
            从纯文本字符串创建 <see cref="T:TouchSocket.Http.StringHttpContent"/> 实例，使用 UTF-8 编码。
            </summary>
            <param name="text">纯文本字符串。</param>
            <returns>返回一个 <see cref="T:TouchSocket.Http.StringHttpContent"/> 实例。</returns>
        </member>
        <member name="T:TouchSocket.Http.IContentTypeProvider">
            <summary>
            IContentTypeProvider
            </summary>
        </member>
        <member name="M:TouchSocket.Http.IContentTypeProvider.TryGetContentType(System.String,System.String@)">
            <summary>
            给定文件路径，确定MIME类型
            </summary>
            <param name="subpath">文件路径</param>
            <param name="contentType">MIME类型</param>
            <returns>如果找到匹配的MIME类型则返回true，否则返回false</returns>
        </member>
        <member name="M:TouchSocket.Http.IContentTypeProvider.Add(System.String,System.String)">
            <summary>
            添加文件路径和MIME类型的映射
            </summary>
            <param name="subpath">文件路径</param>
            <param name="contentType">MIME类型</param>
        </member>
        <member name="T:TouchSocket.Http.IFormCollection">
            <summary>
            表示一个键值对集合，通常用于表示HTTP表单中的数据
            </summary>
        </member>
        <member name="P:TouchSocket.Http.IFormCollection.Count">
            <summary>
            获取集合中键值对的数量
            </summary>
        </member>
        <member name="P:TouchSocket.Http.IFormCollection.Files">
            <summary>
            获取包含上传文件的集合
            </summary>
        </member>
        <member name="P:TouchSocket.Http.IFormCollection.Keys">
            <summary>
            获取集合中所有键的集合
            </summary>
        </member>
        <member name="P:TouchSocket.Http.IFormCollection.Item(System.String)">
            <summary>
            根据键获取对应的值
            </summary>
            <param name="key">要获取值的键</param>
            <returns>与指定键关联的值</returns>
        </member>
        <member name="M:TouchSocket.Http.IFormCollection.Get(System.String)">
            <summary>
            根据键获取对应的值
            </summary>
            <param name="key">要获取的键</param>
            <returns>与指定键关联的值</returns>
        </member>
        <member name="M:TouchSocket.Http.IFormCollection.ContainsKey(System.String)">
            <summary>
            判断集合中是否包含指定的键
            </summary>
            <param name="key">要检查的键</param>
            <returns>如果集合包含指定的键，则返回true；否则返回false</returns>
        </member>
        <member name="M:TouchSocket.Http.IFormCollection.TryGetValue(System.String,System.String@)">
            <summary>
            尝试根据键获取对应的值
            </summary>
            <param name="key">要获取值的键</param>
            <param name="value">与指定键关联的值，如果键不存在则为null</param>
            <returns>如果键存在于集合中，则返回true；否则返回false</returns>
        </member>
        <member name="T:TouchSocket.Http.IFormFile">
            <summary>
            表单文件
            </summary>
        </member>
        <member name="P:TouchSocket.Http.IFormFile.ContentDisposition">
            <summary>
            获取Content-Disposition
            </summary>
        </member>
        <member name="P:TouchSocket.Http.IFormFile.ContentType">
            <summary>
            获取Content-Type
            </summary>
        </member>
        <member name="P:TouchSocket.Http.IFormFile.Data">
            <summary>
            实际的数据
            </summary>
        </member>
        <member name="P:TouchSocket.Http.IFormFile.DataPair">
            <summary>
            数据对
            </summary>
        </member>
        <member name="P:TouchSocket.Http.IFormFile.FileName">
            <summary>
            获取file name
            </summary>
        </member>
        <member name="P:TouchSocket.Http.IFormFile.Length">
            <summary>
            文件长度。在数据接收完成之前，该值为-1;
            </summary>
        </member>
        <member name="P:TouchSocket.Http.IFormFile.Name">
            <summary>
             获取name字段
            </summary>
        </member>
        <member name="T:TouchSocket.Http.IHttpHeader">
            <summary>
            表示http的headers
            </summary>
        </member>
        <member name="M:TouchSocket.Http.IHttpHeader.Get(System.String)">
            <summary>
            获取Header
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.IHttpParams">
            <summary>
            Http参数
            </summary>
        </member>
        <member name="M:TouchSocket.Http.IHttpParams.Get(System.String)">
            <summary>
            获取参数
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.IMultifileCollection">
            <summary>
            定义一个多文件集合接口，继承自IEnumerable{IFormFile}。
            此接口用于统一处理多个文件的集合，提供了遍历集合中每个文件的能力。
            </summary>
        </member>
        <member name="T:TouchSocket.Http.IHttpSocketClient">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.IHttpClientBase">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.DefaultHttpServicePlugin">
            <summary>
            默认的Http服务。为Http做兜底拦截。该插件应该最后添加。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.DefaultHttpServicePlugin.OnHttpRequest(TouchSocket.Http.IHttpSessionClient,TouchSocket.Http.HttpContextEventArgs)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.IHttpPlugin">
            <summary>
            IHttpPlugin
            </summary>
        </member>
        <member name="M:TouchSocket.Http.IHttpPlugin.OnHttpRequest(TouchSocket.Http.IHttpSessionClient,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            在收到Http请求。
            </summary>
            <param name="client"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.FileExtensionContentTypeProvider">
            <summary>
            FileExtensionContentTypeProvider
            </summary>
        </member>
        <member name="M:TouchSocket.Http.FileExtensionContentTypeProvider.#ctor">
            <summary>
            FileExtensionContentTypeProvider
            </summary>
        </member>
        <member name="M:TouchSocket.Http.FileExtensionContentTypeProvider.#ctor(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            FileExtensionContentTypeProvider
            </summary>
            <param name="mapping"></param>
        </member>
        <member name="P:TouchSocket.Http.FileExtensionContentTypeProvider.Mappings">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.FileExtensionContentTypeProvider.TryGetContentType(System.String,System.String@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.FileExtensionContentTypeProvider.Add(System.String,System.String)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.HttpStaticPagePlugin">
            <summary>
            Http静态内容插件
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpStaticPagePlugin.#ctor(TouchSocket.Http.StaticPageOptions)">
            <summary>
            构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpStaticPagePlugin.ContentTypeProvider">
            <summary>
            提供文件扩展名和MIME类型之间的映射。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpStaticPagePlugin.StaticFilesPool">
            <summary>
            静态文件池
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpStaticPagePlugin.NavigateAction">
            <summary>
            重新导航
            </summary>
        </member>
        <member name="P:TouchSocket.Http.HttpStaticPagePlugin.ResponseAction">
            <summary>
            在响应之前调用。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpStaticPagePlugin.ConfigureStaticFilesPool(System.Action{TouchSocket.Http.StaticFilesPool})">
            <summary>
            配置静态文件池
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpStaticPagePlugin.AddFolder(System.String,System.String,System.String,System.Nullable{System.TimeSpan})">
            <summary>
            添加静态文件目录
            </summary>
            <param name="path">Static content path</param>
            <param name="prefix">Cache prefix (default is "/")</param>
            <param name="filter">Cache filter (default is "*.*")</param>
            <param name="timeout">Refresh cache millisecondsTimeout (default is 1 hour)</param>
        </member>
        <member name="M:TouchSocket.Http.HttpStaticPagePlugin.SetContentTypeProvider(TouchSocket.Http.IContentTypeProvider)">
            <summary>
            设置提供文件扩展名和MIME类型之间的映射。
            </summary>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpStaticPagePlugin.SetContentTypeProvider(System.Action{TouchSocket.Http.IContentTypeProvider})">
            <summary>
            设置提供文件扩展名和MIME类型之间的映射。
            </summary>
            <param name="provider">提供文件扩展名和MIME类型之间的映射的操作</param>
            <returns>返回当前的HttpStaticPagePlugin实例</returns>
        </member>
        <member name="M:TouchSocket.Http.HttpStaticPagePlugin.SetNavigateAction(System.Func{TouchSocket.Http.HttpRequest,System.Threading.Tasks.Task{System.String}})">
            <summary>
            设定重新导航
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpStaticPagePlugin.SetNavigateAction(System.Func{TouchSocket.Http.HttpRequest,System.String})">
            <summary>
            设定重新导航
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpStaticPagePlugin.SetResponseAction(System.Func{TouchSocket.Http.HttpContext,System.Threading.Tasks.Task})">
            <summary>
            在响应之前调用。
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpStaticPagePlugin.SetResponseAction(System.Action{TouchSocket.Http.HttpContext})">
            <summary>
            在响应之前调用。
            </summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.HttpStaticPagePlugin.ClearFolder">
            <summary>
            移除所有静态页面
            </summary>
        </member>
        <member name="M:TouchSocket.Http.HttpStaticPagePlugin.RemoveFolder(System.String)">
            <summary>
            移除指定路径的静态文件
            </summary>
            <param name="path">Static content path</param>
        </member>
        <member name="M:TouchSocket.Http.HttpStaticPagePlugin.OnHttpRequest(TouchSocket.Http.IHttpSessionClient,TouchSocket.Http.HttpContextEventArgs)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.StaticEntry">
            <summary>
            表示一个静态条目，可以是字节缓存或文件信息。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.StaticEntry.#ctor(System.Byte[],System.TimeSpan)">
            <summary>
            使用字节数组和超时时间初始化静态条目。
            </summary>
            <param name="value">条目的值，如果条目代表的是字节缓存。</param>
            <param name="timeout">条目的超时时间。</param>
        </member>
        <member name="M:TouchSocket.Http.StaticEntry.#ctor(System.IO.FileInfo,System.TimeSpan)">
            <summary>
            使用FileInfo和超时时间初始化静态条目。
            </summary>
            <param name="fileInfo">条目代表的文件信息。</param>
            <param name="timespan">条目的超时时间。</param>
        </member>
        <member name="P:TouchSocket.Http.StaticEntry.IsCacheBytes">
            <summary>
            获取一个值，指示当前条目是否为字节缓存。
            </summary>
            <value>如果条目的值非空，则为true；否则为false。</value>
        </member>
        <member name="P:TouchSocket.Http.StaticEntry.FileInfo">
            <summary>
            获取或设置与条目关联的文件信息。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.StaticEntry.Value">
            <summary>
            获取与条目关联的字节数组。该值在初始化后不可更改。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.StaticEntry.Timespan">
            <summary>
            获取或设置条目的超时时间。
            </summary>
        </member>
        <member name="T:TouchSocket.Http.StaticFilesPool">
            <summary>
            静态文件缓存池
            </summary>
        </member>
        <member name="M:TouchSocket.Http.StaticFilesPool.#ctor">
            <summary>
            静态文件池的构造函数
            </summary>
        </member>
        <member name="P:TouchSocket.Http.StaticFilesPool.Empty">
            <summary>
            判断文件缓存是否为空
            </summary>
        </member>
        <member name="P:TouchSocket.Http.StaticFilesPool.Count">
            <summary>
            获取文件缓存的数量
            </summary>
        </member>
        <member name="P:TouchSocket.Http.StaticFilesPool.MaxCacheSize">
            <summary>
            对于静态资源缓存的最大尺寸。默认1024*1024。
            </summary>
            <remarks>
            大于设定值的资源只会存储<see cref="T:System.IO.FileInfo"/>，每次访问资源时都会从磁盘加载。
            </remarks>
        </member>
        <member name="M:TouchSocket.Http.StaticFilesPool.Clear">
            <summary>
            清除缓存。
            该方法通过停止文件监视器并清除缓存项，来释放资源。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.StaticFilesPool.AddEntry(System.String,System.Byte[],System.TimeSpan)">
            <summary>
            添加一个新的缓存值
            </summary>
            <param name="key">缓存键</param>
            <param name="value">缓存值，以字节数组形式存储</param>
            <param name="millisecondsTimeout">缓存条目的超时时间，以毫秒为单位</param>
            <returns>始终返回true，表示添加操作已完成</returns>
        </member>
        <member name="M:TouchSocket.Http.StaticFilesPool.AddEntry(System.String,System.IO.FileInfo,System.TimeSpan)">
            <summary>
            向缓存中添加一个条目。
            </summary>
            <param name="key">要添加的条目的键。</param>
            <param name="value">要添加的条目的值，包含文件信息。</param>
            <param name="millisecondsTimeout">条目过期的时间段，以毫秒为单位。</param>
            <returns>总是返回true，表示条目已成功添加。</returns>
        </member>
        <member name="M:TouchSocket.Http.StaticFilesPool.ContainsEntry(System.String)">
            <summary>
            检查给定键是否存在于条目中。
            </summary>
            <param name="key">要检查的键。</param>
            <returns>如果键存在于条目中，则返回 true；否则返回 false。</returns>
            <remarks>
            此方法用于确定是否已经存在具有给定键的条目。
            它首先对键应用路径格式化，然后检查是否存在与格式化后的键相对应的条目。
            使用 ReadLock 确保在读取操作期间数据的一致性。
            </remarks>
        </member>
        <member name="M:TouchSocket.Http.StaticFilesPool.RemoveEntry(System.String)">
            <summary>
            移除指定键的条目。
            </summary>
            <param name="key">要移除的条目的键。</param>
            <returns>如果成功移除，则返回 true；否则返回 false。</returns>
        </member>
        <member name="M:TouchSocket.Http.StaticFilesPool.TryFindEntry(System.String,TouchSocket.Http.StaticEntry@)">
            <summary>
            尝试查找缓存项。
            </summary>
            <param name="key">要查找的键。</param>
            <param name="cacheEntry">找到的缓存项，通过引用返回。</param>
            <returns>如果找到缓存项则返回true；否则返回false。</returns>
        </member>
        <member name="M:TouchSocket.Http.StaticFilesPool.AddFolder(System.String,System.String,System.String,System.Nullable{System.TimeSpan})">
            <summary>
            添加一个文件夹到监控列表。
            </summary>
            <param name="path">要添加的文件夹路径。</param>
            <param name="prefix">文件夹的前缀，默认为"/"。</param>
            <param name="filter">文件过滤器，默认为"*.*"，表示不过滤。</param>
            <param name="timeout">操作超时时间，默认为1小时。</param>
            <returns>添加的文件数量。</returns>
        </member>
        <member name="M:TouchSocket.Http.StaticFilesPool.ContainsFolder(System.String)">
            <summary>
            检查指定路径的文件夹是否存在于集合中。
            </summary>
            <param name="path">要检查的文件夹路径。</param>
            <returns>如果文件夹存在于集合中，则返回true；否则返回false。</returns>
        </member>
        <member name="M:TouchSocket.Http.StaticFilesPool.RemoveFolder(System.String)">
            <summary>
            移除指定路径的文件夹。
            </summary>
            <param name="path">要移除的文件夹路径。</param>
            <returns>如果成功移除文件夹，则返回 true；如果指定路径不存在于文件夹集合中，则返回 false。</returns>
        </member>
        <member name="M:TouchSocket.Http.StaticFilesPool.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.StaticPageOptions">
            <summary>
            静态页面配置
            </summary>
        </member>
        <member name="M:TouchSocket.Http.StaticPageOptions.#ctor">
            <summary>
            构造函数：初始化StaticPageOptions实例
            </summary>
        </member>
        <member name="P:TouchSocket.Http.StaticPageOptions.ContentTypeProvider">
            <summary>
            提供文件扩展名和MIME类型之间的映射。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.StaticPageOptions.FilesPool">
            <summary>
            获取静态文件池对象
            </summary>
        </member>
        <member name="P:TouchSocket.Http.StaticPageOptions.NavigateAction">
            <summary>
            重新导航
            </summary>
        </member>
        <member name="P:TouchSocket.Http.StaticPageOptions.ResponseAction">
            <summary>
            在响应之前调用。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.StaticPageOptions.AddFolder(System.String,System.String,System.String,System.Nullable{System.TimeSpan})">
            <summary>
            添加静态文件目录
            </summary>
            <param name="path">静态内容路径</param>
            <param name="prefix">缓存前缀（默认为"/"）</param>
            <param name="filter">缓存过滤器（默认为"*.*"，表示所有文件）</param>
            <param name="timeout">刷新缓存的时间间隔（以毫秒为单位，默认为1小时）</param>
        </member>
        <member name="M:TouchSocket.Http.StaticPageOptions.SetContentTypeProvider(TouchSocket.Http.IContentTypeProvider)">
            <summary>
            设置提供文件扩展名和MIME类型之间的映射。
            </summary>
            <param name="provider">一个实现了IContentTypeProvider接口的对象，用于提供文件扩展名与MIME类型的映射。</param>
        </member>
        <member name="M:TouchSocket.Http.StaticPageOptions.SetNavigateAction(System.Func{TouchSocket.Http.HttpRequest,System.Threading.Tasks.Task{System.String}})">
            <summary>
            设定重新导航
            </summary>
            <param name="func">一个函数，接受HttpRequest作为参数，并返回一个异步Task，该Task结果为字符串类型的导航目标</param>
        </member>
        <member name="M:TouchSocket.Http.StaticPageOptions.SetNavigateAction(System.Func{TouchSocket.Http.HttpRequest,System.String})">
            <summary>
            设定重新导航
            </summary>
            <param name="func">一个函数，接受一个HttpRequest参数，并返回一个字符串类型的URL</param>
        </member>
        <member name="M:TouchSocket.Http.StaticPageOptions.SetResponseAction(System.Func{TouchSocket.Http.HttpContext,System.Threading.Tasks.Task})">
            <summary>
            在响应之前调用。
            </summary>
            <param name="func">一个委托，包含在响应之前需要执行的操作。该委托接受一个HttpContext参数，返回一个Task对象。</param>
        </member>
        <member name="M:TouchSocket.Http.StaticPageOptions.SetResponseAction(System.Action{TouchSocket.Http.HttpContext})">
            <summary>
            设置一个操作，该操作将在生成响应之前被调用。
            </summary>
            <param name="action">一个接受HttpContext作为参数的Action委托，表示要设置的操作。</param>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.InternalWebSocket.WebSocketReceiveBlockResult.IsCompleted">
            <summary>
            获取表示内存处理是否完成的布尔值。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.InternalWebSocket.WebSocketReceiveBlockResult.Message">
            <summary>
            获取处理结果的消息。
            </summary>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketMessage">
            <summary>
            WebSocket消息结构体，实现了IDisposable接口，用于处理WebSocket消息的生命周期。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketMessage.#ctor(TouchSocket.Http.WebSockets.WSDataType,TouchSocket.Core.ByteBlock,System.Action)">
            <summary>
            初始化WebSocketMessage结构体的新实例。
            </summary>
            <param name="opcode">消息的数据类型，使用WSDataType枚举表示。</param>
            <param name="payloadData">消息的负载数据，使用ByteBlock结构表示。</param>
            <param name="disposeAction">在消息释放时需要调用的动作。</param>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketMessage.Opcode">
            <summary>
            获取消息的数据类型。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketMessage.PayloadData">
            <summary>
            获取消息的负载数据。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketMessage.Dispose">
            <summary>
            释放消息资源。
            </summary>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketMessageCombinator">
            <summary>
            WebSocket消息合并器。其作用是合并具有中继数据的消息
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketMessageCombinator.TryCombine(TouchSocket.Http.WebSockets.WSDataFrame,TouchSocket.Http.WebSockets.WebSocketMessage@)">
            <summary>
            尝试将数据帧组合成WebSocket消息。
            </summary>
            <param name="dataFrame">待组合的数据帧。</param>
            <param name="webSocketMessage">组合成功的WebSocket消息。</param>
            <returns>如果成功组合则返回true；否则返回false。</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketMessageCombinator.Clear">
            <summary>
            清空所有缓存状态及数据。
            </summary>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketOption">
            <summary>
            WebSocket配置
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketOption.Version">
            <summary>
            版本
            </summary>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WSDataFrame">
            <summary>
            WebSocket数据帧
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.FIN">
            <summary>
            是否为最后数据帧。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.IsBinary">
            <summary>
            是否是二进制数据类型
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.IsClose">
            <summary>
            是否是关闭请求
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.IsPing">
            <summary>
            是否是Ping
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.IsPong">
            <summary>
            是否是Pong
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.IsText">
            <summary>
            是否是文本类型
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.Mask">
            <summary>
            计算掩码
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.MaskingKey">
            <summary>
            掩码值
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.MaxLength">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.Opcode">
            <summary>
            数据类型
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.PayloadData">
            <summary>
            有效数据
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.PayloadLength">
            <summary>
            有效载荷数据长度
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.RSV1">
            <summary>
            标识RSV-1。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.RSV2">
            <summary>
            标识RSV-2。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrame.RSV3">
            <summary>
            标识RSV-3。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSDataFrame.Build``1(``0@)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSDataFrame.SetMaskString(System.String)">
            <summary>
            设置Mask。
            </summary>
            <param name="mask"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSDataFrame.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WSTools">
            <summary>
            WSTools
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WSTools.AcceptMask">
            <summary>
            应答。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSTools.CalculateBase64Key(System.String)">
            <summary>
            计算Base64值
            </summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSTools.CreateBase64Key">
            <summary>
            获取Base64随即字符串。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSTools.GetWSRequest(TouchSocket.Http.HttpClientBase,System.String,System.String@)">
            <summary>
            获取WS的请求头
            </summary>
            <param name="httpClientBase"></param>
            <param name="version"></param>
            <param name="base64Key"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSTools.TryGetResponse(TouchSocket.Http.HttpRequest,TouchSocket.Http.HttpResponse)">
            <summary>
            获取响应
            </summary>
            <param name="request"></param>
            <param name="response"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.SetupClientWebSocket">
            <summary>
            表示一个WebSocket客户端的设置配置对象。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.SetupClientWebSocket.#ctor">
            <summary>
            初始化 <see cref="T:TouchSocket.Http.WebSockets.SetupClientWebSocket"/> 类的新实例。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.SetupClientWebSocket.ConnectAsync(System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.SetupClientWebSocket.LastReceivedTime">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.SetupClientWebSocket.LastSentTime">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.SetupClientWebSocket.Protocol">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.SetupClientWebSocket.RemoteIPHost">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.SetupClientWebSocket.ClientWebSocket">
            <summary>
            通讯实际客户端
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.SetupClientWebSocket.Online">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.SetupClientWebSocket.CloseAsync(System.String,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.SetupClientWebSocket.Abort(System.Boolean,System.String)">
            <summary>
            中断连接
            </summary>
            <param name="msg"></param>
            <param name="manual"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.SetupClientWebSocket.Dispose(System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.SetupClientWebSocket.OnWebSocketClosed(TouchSocket.Sockets.ClosedEventArgs)">
            <summary>
            已断开连接。
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.SetupClientWebSocket.OnReceived(System.Net.WebSockets.WebSocketReceiveResult,TouchSocket.Core.ByteBlock)">
            <summary>
            收到数据
            </summary>
            <param name="result"></param>
            <param name="byteBlock"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.SetupClientWebSocket.ProtectedSendAsync(System.ReadOnlyMemory{System.Byte},System.Net.WebSockets.WebSocketMessageType,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            发送数据
            </summary>
            <param name="memory"></param>
            <param name="messageType"></param>
            <param name="endOfMessage"></param>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketClient">
            <summary>
            WebSocketClient用户终端简单实现。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketClient.AllowAsyncRead">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketClient.Client">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketClient.Closed">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketClient.Closing">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketClient.Handshaked">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketClient.Handshaking">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketClient.Received">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClient.OnWebSocketClosed(TouchSocket.Sockets.ClosedEventArgs)">
            <summary>
            当WebSocket连接关闭时执行的任务。
            </summary>
            <param name="e">包含关闭事件相关信息的参数。</param>
            <returns>一个等待完成的任务。</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClient.OnWebSocketClosing(TouchSocket.Sockets.ClosingEventArgs)">
            <summary>
            当WebSocket即将关闭时，执行异步任务。
            </summary>
            <param name="e">提供了关闭事件的相关信息。</param>
            <returns>返回一个异步任务。</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClient.OnWebSocketHandshaked(TouchSocket.Http.HttpContextEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClient.OnWebSocketHandshaking(TouchSocket.Http.HttpContextEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClient.OnWebSocketReceived(TouchSocket.Http.WebSockets.WSDataFrameEventArgs)">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketClient.Version">
            <inheritdoc/>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketClient.CloseStatus">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClient.CloseAsync(System.Net.WebSockets.WebSocketCloseStatus,System.String,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClient.PingAsync">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClient.PongAsync">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClient.ReadAsync(System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClient.SendAsync(TouchSocket.Http.WebSockets.WSDataFrame,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClient.SendAsync(System.String,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClient.SendAsync(System.ReadOnlyMemory{System.Byte},System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketClientBase">
            <summary>
            WebSocket用户终端。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClientBase.#ctor">
            <summary>
            WebSocket用户终端
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketClientBase.Online">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClientBase.ConnectAsync(System.Int32,System.Threading.CancellationToken)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClientBase.OnWebSocketClosed(TouchSocket.Sockets.ClosedEventArgs)">
            <summary>
            当 WebSocket 连接关闭时触发的事件处理程序。
            </summary>
            <param name="e">包含关闭原因和状态代码的事件参数。</param>
            <returns>一个 <see cref="T:System.Threading.Tasks.Task"/> 对象，表示异步操作的完成。</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClientBase.OnWebSocketClosing(TouchSocket.Sockets.ClosingEventArgs)">
            <summary>
            在WebSocket关闭时触发的事件处理程序。
            </summary>
            <param name="e">包含关闭原因和状态码的事件参数。</param>
            <returns>A <see cref="T:System.Threading.Tasks.Task"/> 表示事件处理的异步操作。</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClientBase.OnWebSocketHandshaked(TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            表示完成握手后。
            </summary>
            <param name="e">包含HTTP上下文信息的参数对象。</param>
            <returns>一个表示任务已完成的Task对象。</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClientBase.OnWebSocketHandshaking(TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            表示在即将握手连接时。
            </summary>
            <param name="e">包含HTTP上下文信息的参数对象</param>
            <returns>一个表示异步操作完成的任务</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClientBase.OnWebSocketReceived(TouchSocket.Http.WebSockets.WSDataFrameEventArgs)">
            <summary>
            当收到WS数据时。
            </summary>
            <param name="e">包含接收数据的事件参数</param>
            <returns>一个Task对象，表示异步操作</returns>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketClientBase.WebSocket">
            <summary>
            实际通讯的WebSocket。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClientBase.OnTcpClosed(TouchSocket.Sockets.ClosedEventArgs)">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClientBase.OnTcpReceived(TouchSocket.Sockets.ReceivedDataEventArgs)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter">
            <summary>
            WebSocket适配器
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter.m_surPlusLength">
            <summary>
            数据包剩余长度
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter.m_tempByteBlock">
            <summary>
            临时包
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter.DecodingFromBytes(System.Byte[],System.Int32@,System.Int32,TouchSocket.Http.WebSockets.WSDataFrame@)">
            <summary>
            解码
            </summary>
            <param name="dataBuffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
            <param name="dataFrame"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter.PreviewReceivedAsync(TouchSocket.Core.ByteBlock)">
            <summary>
            当接收到数据时处理数据
            </summary>
            <param name="byteBlock">数据流</param>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter.Reset">
            <inheritdoc/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter.SplitPackageAsync(System.Byte[],System.Int32,System.Int32)">
            <summary>
            分解包
            </summary>
            <param name="dataBuffer"></param>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter2">
            <summary>
            WebSocket适配器
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataHandlingAdapter2.GetInstance">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WSDataFrameEventHandler`1">
            <summary>
            收到WebSocket数据
            </summary>
            <param name="client"></param>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WSDataType">
            <summary>
            WebSocket数据类型
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WSDataType.Cont">
            <summary>
            表示一个中间数据包
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WSDataType.Text">
            <summary>
            表示一个text类型数据包
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WSDataType.Binary">
            <summary>
            表示一个binary类型数据包
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WSDataType.Close">
            <summary>
            表示一个断开连接类型数据包
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WSDataType.Ping">
            <summary>
            表示一个ping类型数据包
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WSDataType.Pong">
            <summary>
            表示一个pong类型数据包
            </summary>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WSDataFrameEventArgs">
            <summary>
            WS数据事件类
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WSDataFrameEventArgs.#ctor(TouchSocket.Http.WebSockets.WSDataFrame)">
            <summary>
            构造函数
            </summary>
            <param name="dataFrame"></param>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WSDataFrameEventArgs.DataFrame">
            <summary>
            WS数据帧。
            </summary>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketConnectException">
            <summary>
            WebSocket连接异常。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketConnectException.#ctor(System.String,TouchSocket.Http.HttpContext)">
            <summary>
            WebSocket连接异常
            </summary>
            <param name="mes"></param>
            <param name="context"></param>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketConnectException.Context">
            <summary>
            HttpContext
            </summary>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketClientExtension">
            <summary>
            WebSocketClientExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketClientExtension.SendAsync(TouchSocket.Http.WebSockets.IWebSocket,System.ReadOnlyMemory{System.Byte},TouchSocket.Http.WebSockets.WSDataType,System.Boolean)">
            <summary>
            异步发送数据帧。
            </summary>
            <param name="webSocket">WebSocket客户端实例。</param>
            <param name="memory">要发送的二进制数据。</param>
            <param name="dataType">数据类型。</param>
            <param name="endOfMessage">是否为消息的结束帧。</param>
            <returns>表示异步操作的任务。</returns>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketDataFrameExtension">
            <summary>
            WebSocket数据帧扩展类
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataFrameExtension.AppendBinary(TouchSocket.Http.WebSockets.WSDataFrame,System.ReadOnlySpan{System.Byte})">
            <summary>
            将二进制数据追加到WSDataFrame对象的PayloadData属性中。
            </summary>
            <param name="dataFrame">要追加数据的WSDataFrame对象。</param>
            <param name="span">要追加的二进制数据，使用<see cref="T:System.ReadOnlySpan`1"/>类型以提高性能。</param>
            <returns>返回修改后的WSDataFrame对象，以便支持链式调用。</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataFrameExtension.AppendText(TouchSocket.Http.WebSockets.WSDataFrame,System.String,System.Text.Encoding)">
            <summary>
            将文本数据追加到WSDataFrame对象的PayloadData中。
            </summary>
            <param name="dataFrame">要追加文本数据的WSDataFrame对象。</param>
            <param name="text">要追加的文本数据。</param>
            <param name="encoding">文本数据的编码方式。默认为UTF8。</param>
            <returns>追加文本数据后的WSDataFrame对象。</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataFrameExtension.BuildRequest``1(TouchSocket.Http.WebSockets.WSDataFrame,``0@)">
            <summary>
            构建请求数据（含Make）
            </summary>
            <param name="dataFrame">数据帧对象，用于封装请求数据</param>
            <param name="byteBlock">字节块对象，用于存储构建的请求数据</param>
            <typeparam name="TByteBlock">泛型参数，指定字节块的类型，必须实现IByteBlock接口</typeparam>
            <remarks>
            此方法通过设置数据帧的Mask属性为true，并确保数据帧具有MaskingKey，
            然后调用dataFrame的Build方法来构建请求数据，并将结果存储在byteBlock中。
            如果MaskingKey未设置，则使用"RRQM"作为默认值。
            </remarks>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataFrameExtension.BuildRequestToBytes(TouchSocket.Http.WebSockets.WSDataFrame)">
            <summary>
            构建请求数据（含Make）
            </summary>
            <param name="dataFrame">要构建的数据帧</param>
            <returns>构建完成的字节数组</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataFrameExtension.BuildResponse``1(TouchSocket.Http.WebSockets.WSDataFrame,``0@)">
            <summary>
            构建响应数据（无Make）
            </summary>
            <param name="dataFrame">待构建的WS数据帧</param>
            <param name="byteBlock">字节块，用于存储构建后的数据</param>
            <remarks>
            该方法直接调用WS数据帧的Build方法来构建数据，
            并将构建结果存储在字节块中，而不是创建一个新的对象。
            这样可以提高性能，减少内存分配。
            </remarks>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataFrameExtension.BuildResponseToBytes(TouchSocket.Http.WebSockets.WSDataFrame)">
            <summary>
            构建响应数据（无Make）
            </summary>
            <param name="dataFrame">要转换为字节数组的数据帧</param>
            <returns>转换后的字节数组</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketDataFrameExtension.ToText(TouchSocket.Http.WebSockets.WSDataFrame,System.Text.Encoding)">
            <summary>
            当数据类型为<see cref="F:TouchSocket.Http.WebSockets.WSDataType.Text"/>时，将数据帧转换为文本消息。
            </summary>
            <param name="dataFrame">要转换的数据帧。</param>
            <param name="encoding">使用的编码方式。如果未指定（默认值），将使用UTF8编码。</param>
            <returns>转换后的文本消息。</returns>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketExtension">
            <summary>
            WebSocket扩展类
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketExtension.ReadStringAsync(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Core.ByteBlock,System.Threading.CancellationToken)">
            <summary>
            异步读取完整字符串。
            <para>
            注意：该访问调用时如果收到非字符串数据则会抛出异常。同时，该方法不可在<see cref="T:TouchSocket.Http.WebSockets.IWebSocket"/>的接收数据事件（插件）中使用。
            相关用法请按照<see cref="M:TouchSocket.Http.WebSockets.IWebSocket.ReadAsync(System.Threading.CancellationToken)"/>进行。
            </para>
            </summary>
            <param name="webSocket">要读取数据的WebSocket实例</param>
            <param name="byteBlock">用于存储接收到的数据的字节块</param>
            <param name="token">用于取消操作的取消令牌</param>
            <returns>返回一个任务，该任务在完成后将包含读取到的字符串</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketExtension.ReadStringAsync(TouchSocket.Http.WebSockets.IWebSocket,System.Threading.CancellationToken)">
            <summary>
            异步读取完整字符串。
            <para>
            注意：该访问调用时如果收到非字符串数据则会抛出异常。同时，该方法不可在<see cref="T:TouchSocket.Http.WebSockets.IWebSocket"/>的接收数据事件（插件）中使用。
            相关用法请按照<see cref="M:TouchSocket.Http.WebSockets.IWebSocket.ReadAsync(System.Threading.CancellationToken)"/>进行。
            </para>
            </summary>
            <param name="webSocket">要读取数据的WebSocket实例</param>
            <param name="token">用于取消异步读取操作的取消令牌</param>
            <returns>返回异步读取到的字符串</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketExtension.ReadBinaryAsync(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Core.ByteBlock,System.Threading.CancellationToken)">
            <summary>
            异步读取完整二进制数据。
            <para>
            注意：该访问调用时如果收到非二进制数据则会抛出异常。同时，该方法不可在<see cref="T:TouchSocket.Http.WebSockets.IWebSocket"/>的接收数据事件（插件）中使用。
            相关用法请按照<see cref="M:TouchSocket.Http.WebSockets.IWebSocket.ReadAsync(System.Threading.CancellationToken)"/>进行。
            </para>
            </summary>
            <param name="webSocket">要读取数据的WebSocket实例。</param>
            <param name="byteBlock">用于存储读取的二进制数据的容器。</param>
            <param name="token">用于取消异步读取操作的取消令牌。</param>
            <returns>返回一个Task对象，表示异步读取操作。</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketExtension.ReadBinaryAsync(TouchSocket.Http.WebSockets.IWebSocket,System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            异步读取完整二进制数据。
            <para>
            注意：该访问调用时如果收到非二进制数据则会抛出异常。同时，该方法不可在<see cref="T:TouchSocket.Http.WebSockets.IWebSocket"/>的接收数据事件（插件）中使用。
            相关用法请按照<see cref="M:TouchSocket.Http.WebSockets.IWebSocket.ReadAsync(System.Threading.CancellationToken)"/>进行。
            </para>
            </summary>
            <param name="webSocket">要读取数据的WebSocket实例。</param>
            <param name="stream">用于存储读取的二进制数据的流。</param>
            <param name="token">用于取消异步读取操作的取消令牌。默认值为<see cref="P:System.Threading.CancellationToken.None"/>。</param>
            <returns>返回一个<see cref="T:System.Threading.Tasks.Task"/>对象，表示异步读取操作。</returns>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WebSocketExtension.WebSocketMessageCombinatorProperty">
            <summary>
            WebSocketMessageCombinatorProperty
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketExtension.GetMessageCombinator(TouchSocket.Http.WebSockets.IWebSocket)">
            <summary>
            获取消息合并器。
            </summary>
            <param name="webSocket">WebSocket实例</param>
            <returns>消息合并器实例</returns>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.IWebSocket">
            <summary>
            定义WebSocket服务的接口，继承自IDisposable, IOnlineClient, IClosableClient接口。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.IWebSocket.AllowAsyncRead">
            <summary>
            允许异步Read读取
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.IWebSocket.Client">
            <summary>
            使用的Http客户端
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.IWebSocket.Version">
            <summary>
            WebSocket版本
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.IWebSocket.CloseStatus">
            <summary>
            获取最后WebSocket关闭状态。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocket.CloseAsync(System.Net.WebSockets.WebSocketCloseStatus,System.String,System.Threading.CancellationToken)">
            <summary>
            异步关闭WebSocket连接。
            </summary>
            <param name="closeStatus">关闭状态。</param>
            <param name="statusDescription">状态描述。</param>
            <param name="token">可取消令箭</param>
            <returns>返回一个任务对象，表示异步操作的结果。</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocket.PingAsync">
            <summary>
            异步发送Ping请求。
            </summary>
            <returns>任务完成时返回。</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocket.PongAsync">
            <summary>
            异步执行Pong操作。
            </summary>
            <returns>一个任务对象，表示异步操作的完成。</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocket.ReadAsync(System.Threading.CancellationToken)">
            <summary>
            异步等待读取数据
            </summary>
            <param name="token">用于取消异步读取操作的取消令牌</param>
            <returns>返回一个值任务，该任务完成后将包含WebSocket接收的结果</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocket.SendAsync(TouchSocket.Http.WebSockets.WSDataFrame,System.Boolean)">
            <summary>
            采用WebSocket协议，发送WS数据。发送结束后，请及时释放<see cref="T:TouchSocket.Http.WebSockets.WSDataFrame"/>
            </summary>
            <param name="dataFrame">要发送的数据帧</param>
            <param name="endOfMessage">是否是消息的结束标志，默认为true</param>
            <returns>返回一个异步任务，用于指示发送操作的完成状态</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocket.SendAsync(System.String,System.Boolean)">
            <summary>
            异步发送文本消息。
            </summary>
            <param name="text">要发送的文本内容。</param>
            <param name="endOfMessage">指示是否是消息的结束。默认为true。</param>
            <returns>返回一个任务对象，表示异步操作的结果。</returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocket.SendAsync(System.ReadOnlyMemory{System.Byte},System.Boolean)">
            <summary>
            异步发送指定的字节内存数据。
            </summary>
            <param name="memory">要发送的字节数据，作为只读内存块。</param>
            <param name="endOfMessage">指示当前数据是否为消息的结束。默认为true。</param>
            <remarks>
            此方法允许异步发送数据，通过指定是否为消息的结束来控制数据流。
            </remarks>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.IWebSocketClient">
            <summary>
            用户终端接口
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.IWebSocketClient.Closed">
            <summary>
            当WebSocket断开时触发。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.IWebSocketClient.Closing">
            <summary>
            当WebSocket收到Close报文时触发。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.IWebSocketClient.Handshaked">
            <summary>
            表示完成握手后。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.IWebSocketClient.Handshaking">
            <summary>
            表示在即将握手连接时。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.IWebSocketClient.Received">
            <summary>
            收到WebSocket数据
            </summary>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.IWebSocketReceiveResult">
            <summary>
            定义WebSocket接收结果的接口，继承自IDisposable接口
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.IWebSocketReceiveResult.DataFrame">
            <summary>
            WebSocket数据帧
            </summary>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.IWebSocketClosedPlugin">
            <summary>
            IWebSocketClosedPlugin
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocketClosedPlugin.OnWebSocketClosed(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Sockets.ClosedEventArgs)">
            <summary>
            表示WebSocket已经断开连接。
            </summary>
            <param name="webSocket"></param>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.IWebSocketClosingPlugin">
            <summary>
            IWebSocketClosingPlugin
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocketClosingPlugin.OnWebSocketClosing(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Sockets.ClosingEventArgs)">
            <summary>
            表示收到断开连接报文。如果对方直接断开连接，此方法则不会触发。
            </summary>
            <param name="webSocket"></param>
            <param name="e"></param>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.IWebSocketHandshakedPlugin">
            <summary>
            IWebSocketHandshakedPlugin
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocketHandshakedPlugin.OnWebSocketHandshaked(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            表示完成握手后。
            </summary>
            <param name="webSocket"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.IWebSocketHandshakingPlugin">
            <summary>
            IWebSocketHandshakingPlugin
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocketHandshakingPlugin.OnWebSocketHandshaking(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.HttpContextEventArgs)">
            <summary>
            表示在即将握手连接时。
            </summary>
            <param name="webSocket"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.IWebSocketReceivedPlugin">
            <summary>
            IWebSocketReceivedPlugin
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.IWebSocketReceivedPlugin.OnWebSocketReceived(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.WebSockets.WSDataFrameEventArgs)">
            <summary>
            当收到WS数据时。
            </summary>
            <param name="webSocket"></param>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketCommandLinePlugin">
            <summary>
            WS命令行插件。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketCommandLinePlugin.#ctor(TouchSocket.Core.ILog)">
            <summary>
            WSCommandLinePlugin
            </summary>
            <param name="logger"></param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketCommandLinePlugin.Converter">
            <summary>
            字符串转换器，默认支持基础类型和Json。可以自定义。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketCommandLinePlugin.ReturnException">
            <summary>
            是否返回执行异常。
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketCommandLinePlugin.NoReturnException">
            <summary>
            当有执行异常时，不返回异常。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketCommandLinePlugin.OnWebSocketReceived(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.WebSockets.WSDataFrameEventArgs)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketFeature">
            <summary>
            基于Http的WebSocket的扩展。
            <para>此组件只能挂载在<see cref="T:TouchSocket.Http.HttpService"/>中</para>
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WebSocketFeature.AutoCloseProperty">
            <summary>
            自动响应Close报文
            </summary>
        </member>
        <member name="F:TouchSocket.Http.WebSockets.WebSocketFeature.AutoPongProperty">
            <summary>
            自动响应Ping报文
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketFeature.#ctor">
            <summary>
            WebSocketFeature
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketFeature.AutoClose">
            <summary>
            是否默认处理Close报文。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketFeature.AutoPong">
            <summary>
            当收到ping报文时，是否自动回应pong。
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketFeature.VerifyConnection">
            <summary>
            验证连接
            </summary>
        </member>
        <member name="P:TouchSocket.Http.WebSockets.WebSocketFeature.WSUrl">
            <summary>
            用于WebSocket连接的路径，默认为“/ws”
            <para>如果设置为null或空，则意味着所有的连接都将解释为WS</para>
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketFeature.NoAutoClose">
            <summary>
            不处理Close报文。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketFeature.SetVerifyConnection(System.Func{TouchSocket.Http.IHttpSessionClient,TouchSocket.Http.HttpContext,System.Boolean})">
            <summary>
            验证连接
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketFeature.SetVerifyConnection(System.Func{TouchSocket.Http.IHttpSessionClient,TouchSocket.Http.HttpContext,System.Threading.Tasks.Task{System.Boolean}})">
            <summary>
            验证连接
            </summary>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketFeature.SetWSUrl(System.String)">
            <summary>
            用于WebSocket连接的路径，默认为“/ws”
            <para>如果设置为null或空，则意味着所有的连接都将解释为WS</para>
            </summary>
            <param name="url"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketFeature.UseAutoPong">
            <summary>
            当收到ping报文时，自动回应pong。
            </summary>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketFeature.OnHttpRequest(TouchSocket.Http.IHttpSessionClient,TouchSocket.Http.HttpContextEventArgs)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.WebSockets.WebSocketHeartbeatPlugin">
            <summary>
            初始化一个适用于WebSocket的心跳插件
            </summary>
        </member>
        <member name="M:TouchSocket.Http.WebSockets.WebSocketHeartbeatPlugin.OnWebSocketHandshaked(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.HttpContextEventArgs)">
            <inheritdoc/>
        </member>
        <member name="T:TouchSocket.Http.WebSockets._WebSocketClosedPluginExtensions">
            <inheritdoc cref = "T:TouchSocket.Http.WebSockets.IWebSocketClosedPlugin"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketClosedPluginExtensions.AddWebSocketClosedPlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Sockets.ClosedEventArgs,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketClosedPlugin.OnWebSocketClosed(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Sockets.ClosedEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketClosedPluginExtensions.AddWebSocketClosedPlugin(TouchSocket.Core.IPluginManager,System.Action{TouchSocket.Http.WebSockets.IWebSocket})">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketClosedPlugin.OnWebSocketClosed(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Sockets.ClosedEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketClosedPluginExtensions.AddWebSocketClosedPlugin(TouchSocket.Core.IPluginManager,System.Action)">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketClosedPlugin.OnWebSocketClosed(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Sockets.ClosedEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketClosedPluginExtensions.AddWebSocketClosedPlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Sockets.ClosedEventArgs,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketClosedPlugin.OnWebSocketClosed(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Sockets.ClosedEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketClosedPluginExtensions.AddWebSocketClosedPlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Http.WebSockets.IWebSocket,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketClosedPlugin.OnWebSocketClosed(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Sockets.ClosedEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketClosedPluginExtensions.AddWebSocketClosedPlugin(TouchSocket.Core.IPluginManager,System.Func{System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketClosedPlugin.OnWebSocketClosed(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Sockets.ClosedEventArgs)"/>
        </member>
        <member name="T:TouchSocket.Http.WebSockets._WebSocketClosingPluginExtensions">
            <inheritdoc cref = "T:TouchSocket.Http.WebSockets.IWebSocketClosingPlugin"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketClosingPluginExtensions.AddWebSocketClosingPlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Sockets.ClosingEventArgs,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketClosingPlugin.OnWebSocketClosing(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Sockets.ClosingEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketClosingPluginExtensions.AddWebSocketClosingPlugin(TouchSocket.Core.IPluginManager,System.Action{TouchSocket.Http.WebSockets.IWebSocket})">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketClosingPlugin.OnWebSocketClosing(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Sockets.ClosingEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketClosingPluginExtensions.AddWebSocketClosingPlugin(TouchSocket.Core.IPluginManager,System.Action)">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketClosingPlugin.OnWebSocketClosing(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Sockets.ClosingEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketClosingPluginExtensions.AddWebSocketClosingPlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Sockets.ClosingEventArgs,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketClosingPlugin.OnWebSocketClosing(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Sockets.ClosingEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketClosingPluginExtensions.AddWebSocketClosingPlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Http.WebSockets.IWebSocket,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketClosingPlugin.OnWebSocketClosing(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Sockets.ClosingEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketClosingPluginExtensions.AddWebSocketClosingPlugin(TouchSocket.Core.IPluginManager,System.Func{System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketClosingPlugin.OnWebSocketClosing(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Sockets.ClosingEventArgs)"/>
        </member>
        <member name="T:TouchSocket.Http.WebSockets._WebSocketHandshakedPluginExtensions">
            <inheritdoc cref = "T:TouchSocket.Http.WebSockets.IWebSocketHandshakedPlugin"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketHandshakedPluginExtensions.AddWebSocketHandshakedPlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.HttpContextEventArgs,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketHandshakedPlugin.OnWebSocketHandshaked(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.HttpContextEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketHandshakedPluginExtensions.AddWebSocketHandshakedPlugin(TouchSocket.Core.IPluginManager,System.Action{TouchSocket.Http.WebSockets.IWebSocket})">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketHandshakedPlugin.OnWebSocketHandshaked(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.HttpContextEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketHandshakedPluginExtensions.AddWebSocketHandshakedPlugin(TouchSocket.Core.IPluginManager,System.Action)">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketHandshakedPlugin.OnWebSocketHandshaked(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.HttpContextEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketHandshakedPluginExtensions.AddWebSocketHandshakedPlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Http.HttpContextEventArgs,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketHandshakedPlugin.OnWebSocketHandshaked(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.HttpContextEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketHandshakedPluginExtensions.AddWebSocketHandshakedPlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Http.WebSockets.IWebSocket,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketHandshakedPlugin.OnWebSocketHandshaked(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.HttpContextEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketHandshakedPluginExtensions.AddWebSocketHandshakedPlugin(TouchSocket.Core.IPluginManager,System.Func{System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketHandshakedPlugin.OnWebSocketHandshaked(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.HttpContextEventArgs)"/>
        </member>
        <member name="T:TouchSocket.Http.WebSockets._WebSocketHandshakingPluginExtensions">
            <inheritdoc cref = "T:TouchSocket.Http.WebSockets.IWebSocketHandshakingPlugin"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketHandshakingPluginExtensions.AddWebSocketHandshakingPlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.HttpContextEventArgs,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketHandshakingPlugin.OnWebSocketHandshaking(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.HttpContextEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketHandshakingPluginExtensions.AddWebSocketHandshakingPlugin(TouchSocket.Core.IPluginManager,System.Action{TouchSocket.Http.WebSockets.IWebSocket})">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketHandshakingPlugin.OnWebSocketHandshaking(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.HttpContextEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketHandshakingPluginExtensions.AddWebSocketHandshakingPlugin(TouchSocket.Core.IPluginManager,System.Action)">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketHandshakingPlugin.OnWebSocketHandshaking(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.HttpContextEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketHandshakingPluginExtensions.AddWebSocketHandshakingPlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Http.HttpContextEventArgs,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketHandshakingPlugin.OnWebSocketHandshaking(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.HttpContextEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketHandshakingPluginExtensions.AddWebSocketHandshakingPlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Http.WebSockets.IWebSocket,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketHandshakingPlugin.OnWebSocketHandshaking(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.HttpContextEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketHandshakingPluginExtensions.AddWebSocketHandshakingPlugin(TouchSocket.Core.IPluginManager,System.Func{System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketHandshakingPlugin.OnWebSocketHandshaking(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.HttpContextEventArgs)"/>
        </member>
        <member name="T:TouchSocket.Http.WebSockets._WebSocketReceivedPluginExtensions">
            <inheritdoc cref = "T:TouchSocket.Http.WebSockets.IWebSocketReceivedPlugin"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketReceivedPluginExtensions.AddWebSocketReceivedPlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.WebSockets.WSDataFrameEventArgs,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketReceivedPlugin.OnWebSocketReceived(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.WebSockets.WSDataFrameEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketReceivedPluginExtensions.AddWebSocketReceivedPlugin(TouchSocket.Core.IPluginManager,System.Action{TouchSocket.Http.WebSockets.IWebSocket})">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketReceivedPlugin.OnWebSocketReceived(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.WebSockets.WSDataFrameEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketReceivedPluginExtensions.AddWebSocketReceivedPlugin(TouchSocket.Core.IPluginManager,System.Action)">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketReceivedPlugin.OnWebSocketReceived(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.WebSockets.WSDataFrameEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketReceivedPluginExtensions.AddWebSocketReceivedPlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Http.WebSockets.WSDataFrameEventArgs,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketReceivedPlugin.OnWebSocketReceived(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.WebSockets.WSDataFrameEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketReceivedPluginExtensions.AddWebSocketReceivedPlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Http.WebSockets.IWebSocket,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketReceivedPlugin.OnWebSocketReceived(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.WebSockets.WSDataFrameEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http.WebSockets._WebSocketReceivedPluginExtensions.AddWebSocketReceivedPlugin(TouchSocket.Core.IPluginManager,System.Func{System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Http.WebSockets.IWebSocketReceivedPlugin.OnWebSocketReceived(TouchSocket.Http.WebSockets.IWebSocket,TouchSocket.Http.WebSockets.WSDataFrameEventArgs)"/>
        </member>
        <member name="T:TouchSocket.Http._HttpPluginExtensions">
            <inheritdoc cref = "T:TouchSocket.Http.IHttpPlugin"/>
        </member>
        <member name="M:TouchSocket.Http._HttpPluginExtensions.AddHttpPlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Http.IHttpSessionClient,TouchSocket.Http.HttpContextEventArgs,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Http.IHttpPlugin.OnHttpRequest(TouchSocket.Http.IHttpSessionClient,TouchSocket.Http.HttpContextEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http._HttpPluginExtensions.AddHttpPlugin(TouchSocket.Core.IPluginManager,System.Action{TouchSocket.Http.IHttpSessionClient})">
            <inheritdoc cref = "M:TouchSocket.Http.IHttpPlugin.OnHttpRequest(TouchSocket.Http.IHttpSessionClient,TouchSocket.Http.HttpContextEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http._HttpPluginExtensions.AddHttpPlugin(TouchSocket.Core.IPluginManager,System.Action)">
            <inheritdoc cref = "M:TouchSocket.Http.IHttpPlugin.OnHttpRequest(TouchSocket.Http.IHttpSessionClient,TouchSocket.Http.HttpContextEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http._HttpPluginExtensions.AddHttpPlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Http.HttpContextEventArgs,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Http.IHttpPlugin.OnHttpRequest(TouchSocket.Http.IHttpSessionClient,TouchSocket.Http.HttpContextEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http._HttpPluginExtensions.AddHttpPlugin(TouchSocket.Core.IPluginManager,System.Func{TouchSocket.Http.IHttpSessionClient,System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Http.IHttpPlugin.OnHttpRequest(TouchSocket.Http.IHttpSessionClient,TouchSocket.Http.HttpContextEventArgs)"/>
        </member>
        <member name="M:TouchSocket.Http._HttpPluginExtensions.AddHttpPlugin(TouchSocket.Core.IPluginManager,System.Func{System.Threading.Tasks.Task})">
            <inheritdoc cref = "M:TouchSocket.Http.IHttpPlugin.OnHttpRequest(TouchSocket.Http.IHttpSessionClient,TouchSocket.Http.HttpContextEventArgs)"/>
        </member>
        <member name="T:TouchSocket.Sockets.HttpConfigExtensions">
            <summary>
            HttpConfigExtensions
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.HttpConfigExtensions.HttpProxyProperty">
            <summary>
            Http代理
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.HttpConfigExtensions.SetHttpProxy(TouchSocket.Core.TouchSocketConfig,TouchSocket.Http.HttpProxy)">
             <summary>
            设置Http代理
             </summary>
             <param name="config"></param>
             <param name="value"></param>
             <returns></returns>
        </member>
        <member name="T:TouchSocket.Sockets.WebSocketConfigExtension">
            <summary>
            WebSocketConfigExtensions
            </summary>
        </member>
        <member name="F:TouchSocket.Sockets.WebSocketConfigExtension.WebSocketOptionProperty">
            <summary>
            WebSocket配置属性
            </summary>
        </member>
        <member name="M:TouchSocket.Sockets.WebSocketConfigExtension.SetWebSocketOption(TouchSocket.Core.TouchSocketConfig,TouchSocket.Http.WebSockets.WebSocketOption)">
            <summary>
            设置WebSocket的相关配置
            </summary>
            <param name="config"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.HttpPluginManagerExtension">
            <summary>
            HttpPluginManagerExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Core.HttpPluginManagerExtension.UseDefaultHttpServicePlugin(TouchSocket.Core.IPluginManager)">
            <summary>
            使用默认的Http服务插件。该插件作为Http请求的默认处理者，用于拦截未被其他插件处理的Http请求。
            该方法通过扩展方法的方式，允许插件管理器动态添加此默认Http服务插件。
            </summary>
            <param name="pluginManager">插件管理器，负责管理和添加插件。</param>
            <returns>返回创建并添加到插件管理器的默认Http服务插件实例。</returns>
        </member>
        <member name="M:TouchSocket.Core.HttpPluginManagerExtension.UseHttpStaticPage(TouchSocket.Core.IPluginManager,System.Action{TouchSocket.Http.StaticPageOptions})">
            <summary>
            静态页面插件扩展方法
            </summary>
            <param name="pluginManager">插件管理器实例</param>
            <param name="optionsAction">配置操作委托，用于配置静态页面选项</param>
            <returns>配置后的静态页面插件实例</returns>
        </member>
        <member name="M:TouchSocket.Core.HttpPluginManagerExtension.UseHttpStaticPage(TouchSocket.Core.IPluginManager)">
            <summary>
            静态方法，用于通过插件管理器启用HTTP静态页面服务插件
            </summary>
            <param name="pluginManager">插件管理器对象，用于添加和管理插件</param>
            <returns>返回创建的HTTP静态页面服务插件实例</returns>
        </member>
        <member name="M:TouchSocket.Core.HttpPluginManagerExtension.UseCors(TouchSocket.Core.IPluginManager,System.String)">
            <summary>
            启用跨域功能
            </summary>
            <param name="pluginManager">插件管理器</param>
            <param name="policyName">跨域策略名称</param>
            <returns>返回一个新的CorsPlugin实例</returns>
        </member>
        <member name="T:TouchSocket.Core.WebSocketPluginManagerExtension">
            <summary>
            WebSocketPluginManagerExtension
            </summary>
        </member>
        <member name="M:TouchSocket.Core.WebSocketPluginManagerExtension.UseWebSocket(TouchSocket.Core.IPluginManager)">
            <summary>
            使用WebSocket插件。
            </summary>
            <returns>插件类型实例</returns>
        </member>
        <member name="M:TouchSocket.Core.WebSocketPluginManagerExtension.UseWebSocketHeartbeat(TouchSocket.Core.IPluginManager)">
            <summary>
            使用WebSocket心跳插件，客户端、服务器均有效。但是一般建议客户端使用即可。
            </summary>
            <returns>插件类型实例</returns>
        </member>
        <member name="M:TouchSocket.Core.WebSocketPluginManagerExtension.UseWebSocketReconnection``1(TouchSocket.Core.IPluginManager)">
            <summary>
            使用<see cref="T:TouchSocket.Http.WebSockets.IWebSocketClient"/>断线重连。
            </summary>
            <typeparam name="TClient"></typeparam>
            <param name="pluginManager"></param>
            <returns></returns>
        </member>
        <member name="M:TouchSocket.Core.WebSocketPluginManagerExtension.UseWebSocketReconnection(TouchSocket.Core.IPluginManager)">
            <summary>
            使用<see cref="T:TouchSocket.Http.WebSockets.IWebSocketClient"/>断线重连。
            </summary>
            <param name="pluginManager"></param>
            <returns></returns>
        </member>
        <member name="T:TouchSocket.Core.FastSerializableAttribute">
            <summary>
            标识源生成Fast序列化相关的实现。
            </summary>
        </member>
        <member name="T:TouchSocket.Core.GeneratorPackageAttribute">
            <summary>
            标识源生成<see cref="T:TouchSocket.Core.IPackage"/>的实现。
            </summary>
        </member>
        <member name="T:TouchSocket.Core.PackageMemberAttribute">
            <summary>
            标识源生成<see cref="T:TouchSocket.Core.IPackage"/>成员的特性。
            </summary>
        </member>
        <member name="P:TouchSocket.Core.PackageMemberAttribute.Behavior">
            <summary>
            生成行为。一般来说，对于非只读、非重写、且同时拥有get，set（可以私有）访问器的属性，会自动生成。
            对于字段，均不会自动生成。所以可以使用该设置，来指示生成器的生成行为。
            </summary>
        </member>
        <member name="T:TouchSocket.Resources.TouchSocketHttpResource">
            <summary>
              一个强类型的资源类，用于查找本地化的字符串等。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketHttpResource.ResourceManager">
            <summary>
              返回此类使用的缓存的 ResourceManager 实例。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketHttpResource.Culture">
            <summary>
              重写当前线程的 CurrentUICulture 属性，对
              使用此强类型资源类的所有资源查找执行重写。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketHttpResource.NotAllowAsyncRead">
            <summary>
              查找类似 When AllowAsynchronous Read is false, this operation is not supported. 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketHttpResource.ProtocolIsIncorrect">
            <summary>
              查找类似 Protocol is incorrect. 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketHttpResource.RefuseWebSocketConnection">
            <summary>
              查找类似 Proactively reject WebSocket connection, information: {0} 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketHttpResource.RequestHasBeenResponded">
            <summary>
              查找类似 The current HTTP request has been responded to and cannot be processed again. 的本地化字符串。
            </summary>
        </member>
        <member name="P:TouchSocket.Resources.TouchSocketHttpResource.WebSocketConnectionProtocolIsIncorrect">
            <summary>
              查找类似 The WebSocket connection protocol is incorrect, this may not be a WebSocket connection. 的本地化字符串。
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.ConstantExpectedAttribute">
            <summary>
            Indicates that the specified method parameter expects a constant.
            </summary>
            <remarks>
            This can be used to inform tooling that a constant should be used as an argument for the annotated parameter.
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.ConstantExpectedAttribute.Min">
            <summary>
            Indicates the minimum bound of the expected constant, inclusive.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.ConstantExpectedAttribute.Max">
            <summary>
            Indicates the maximum bound of the expected constant, inclusive.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.ExperimentalAttribute">
            <summary>
            Indicates that an API is experimental and it may change in the future.
            </summary>
            <remarks>
            This attribute allows call sites to be flagged with a diagnostic that indicates that an experimental
            feature is used. Authors can use this attribute to ship preview features in their assemblies.
            </remarks>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.ExperimentalAttribute"/> class,
            specifying the ID that the compiler will use when reporting a use of the API the attribute applies to.
            </summary>
            <param name="diagnosticId">The ID that the compiler will use when reporting a use of the API the attribute applies to.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.DiagnosticId">
            <summary>
            Gets the ID that the compiler will use when reporting a use of the API the attribute applies to.
            </summary>
            <value>The unique diagnostic ID.</value>
            <remarks>
            The diagnostic ID is shown in build output for warnings and errors.
            <para>This property represents the unique ID that can be used to suppress the warnings or errors, if needed.</para>
            </remarks>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.ExperimentalAttribute.UrlFormat">
            <summary>
            Gets or sets the URL for corresponding documentation.
            The API accepts a format string instead of an actual URL, creating a generic URL that includes the diagnostic ID.
            </summary>
            <value>The format string that represents a URL to corresponding documentation.</value>
            <remarks>An example format string is <c>https://contoso.com/obsoletion-warnings/{0}</c>.</remarks>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>
            Specifies that the method or property will ensure that the listed field and property members have not-null values.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)">
            <summary>
            Initializes the attribute with a field or property member.
            </summary>
            <param name="member">The field or property member that is promised to be not-null.</param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])">
            <summary>
            Initializes the attribute with the list of field and property members.
            </summary>
            <param name="members">The list of field and property members that are promised to be not-null.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.Members">
            <summary>
            Gets field or property member names.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>
            Specifies that the method or property will ensure that the listed field and property
            members have not-null values when returning with the specified return value condition.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)">
            <summary>
            Initializes the attribute with the specified return value condition and a field or property member.
            </summary>
            <param name="returnValue">The return value condition. If the method returns this value, the associated parameter will not be null.</param>
            <param name="member">The field or property member that is promised to be not-null.</param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])">
            <summary>
            Initializes the attribute with the specified return value condition and list of field and property members.
            </summary>
            <param name="returnValue">The return value condition. If the method returns this value, the associated parameter will not be null.</param>
            <param name="members">The list of field and property members that are promised to be not-null.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.ReturnValue">
            <summary>
            Gets the return value condition.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.Members">
            <summary>
            Gets field or property member names.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute">
            <summary>
            Specifies that this constructor sets all required members for the current type,
            and callers do not need to set any required members themselves.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute">
            <summary>
            Specifies the syntax used in a string.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.#ctor(System.String)">
            <summary>
            Initializes the <see cref="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute"/> with the identifier of the syntax used.
            </summary>
            <param name="syntax">The syntax identifier.</param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.#ctor(System.String,System.Object[])">
            <summary>Initializes the <see cref="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute"/> with the identifier of the syntax used.</summary>
            <param name="syntax">The syntax identifier.</param>
            <param name="arguments">Optional arguments associated with the specific syntax employed.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Syntax">
            <summary>Gets the identifier of the syntax used.</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Arguments">
            <summary>Optional arguments associated with the specific syntax employed.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.CompositeFormat">
            <summary>The syntax identifier for strings containing composite formats for string formatting.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.DateOnlyFormat">
            <summary>The syntax identifier for strings containing date format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.DateTimeFormat">
            <summary>The syntax identifier for strings containing date and time format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.EnumFormat">
            <summary>The syntax identifier for strings containing <see cref="T:System.Enum"/> format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.GuidFormat">
            <summary>The syntax identifier for strings containing <see cref="T:System.Guid"/> format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Json">
            <summary>The syntax identifier for strings containing JavaScript Object Notation (JSON).</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.NumericFormat">
            <summary>The syntax identifier for strings containing numeric format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Regex">
            <summary>The syntax identifier for strings containing regular expressions.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.TimeOnlyFormat">
            <summary>The syntax identifier for strings containing time format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.TimeSpanFormat">
            <summary>The syntax identifier for strings containing <see cref="T:System.TimeSpan"/> format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Uri">
            <summary>The syntax identifier for strings containing URIs.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Xml">
            <summary>The syntax identifier for strings containing XML.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute">
            <summary>
            Used to indicate a byref escapes and is not scoped.
            </summary>
            <remarks>
            <para>
            There are several cases where the C# compiler treats a <see langword="ref"/> as implicitly
            <see langword="scoped"/> - where the compiler does not allow the <see langword="ref"/> to escape the method.
            </para>
            <para>
            For example:
            <list type="number">
                <item><see langword="this"/> for <see langword="struct"/> instance methods.</item>
                <item><see langword="ref"/> parameters that refer to <see langword="ref"/> <see langword="struct"/> types.</item>
                <item><see langword="out"/> parameters.</item>
            </list>
            </para>
            <para>
            This attribute is used in those instances where the <see langword="ref"/> should be allowed to escape.
            </para>
            <para>
            Applying this attribute, in any form, has impact on consumers of the applicable API. It is necessary for
            API authors to understand the lifetime implications of applying this attribute and how it may impact their users.
            </para>
            </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute">
            <summary>
            An attribute that allows parameters to receive the expression of other parameters.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute"/> class.
            </summary>
            <param name="parameterName">The condition parameter value.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute.ParameterName">
            <summary>
            Gets the parameter name the expression is retrieved from.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.CollectionBuilderAttribute.#ctor(System.Type,System.String)">
            <summary>
            Initialize the attribute to refer to the <paramref name="methodName"/> method on the <paramref name="builderType"/> type.
            </summary>
            <param name="builderType">The type of the builder to use to construct the collection.</param>
            <param name="methodName">The name of the method on the builder to use to construct the collection.</param>
            <remarks>
            <paramref name="methodName"/> must refer to a static method that accepts a single parameter of
            type <see cref="T:System.ReadOnlySpan`1"/> and returns an instance of the collection being built containing
            a copy of the data from that span.  In future releases of .NET, additional patterns may be supported.
            </remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.CollectionBuilderAttribute.BuilderType">
            <summary>
            Gets the type of the builder to use to construct the collection.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.CollectionBuilderAttribute.MethodName">
            <summary>
            Gets the name of the method on the builder to use to construct the collection.
            </summary>
            <remarks>
            This should match the metadata name of the target method.
            For example, this might be ".ctor" if targeting the type's constructor.
            </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute">
            <summary>
            Indicates that compiler support for a particular feature is required for the location where this attribute is applied.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.#ctor(System.String)">
            <summary>
            Creates a new instance of the <see cref="T:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute"/> type.
            </summary>
            <param name="featureName">The name of the feature to indicate.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName">
            <summary>
            The name of the compiler feature.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.IsOptional">
            <summary>
            If true, the compiler can choose to allow access to the location where this attribute is applied if it does not understand <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/>.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.RefStructs">
            <summary>
            The <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/> used for the ref structs C# feature.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.RequiredMembers">
            <summary>
            The <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/> used for the required members C# feature.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute">
            <summary>
            Indicates which arguments to a method involving an interpolated string handler should be passed to that handler.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.
            </summary>
            <param name="argument">The name of the argument that should be passed to the handler.</param>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.
            </summary>
            <param name="arguments">The names of the arguments that should be passed to the handler.</param>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.Arguments">
            <summary>
            Gets the names of the arguments that should be passed to the handler.
            </summary>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute">
            <summary>
            Indicates the attributed type is to be used as an interpolated string handler.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.IsExternalInit">
            <summary>
            Reserved to be used by the compiler for tracking metadata.
            This class should not be used by developers in source code.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.ModuleInitializerAttribute">
             <summary>
             Used to indicate to the compiler that a method should be called
             in its containing module's initializer.
             </summary>
             <remarks>
             When one or more valid methods
             with this attribute are found in a compilation, the compiler will
             emit a module initializer which calls each of the attributed methods.
            
             Certain requirements are imposed on any method targeted with this attribute:
             - The method must be `static`.
             - The method must be an ordinary member method, as opposed to a property accessor, constructor, local function, etc.
             - The method must be parameterless.
             - The method must return `void`.
             - The method must not be generic or be contained in a generic type.
             - The method's effective accessibility must be `internal` or `public`.
            
             The specification for module initializers in the .NET runtime can be found here:
             https://github.com/dotnet/runtime/blob/main/docs/design/specs/Ecma-335-Augments.md#module-initializer
             </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute">
            <summary>
            Specifies the priority of a member in overload resolution. When unspecified, the default priority is 0.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute"/> class.
            </summary>
            <param name="priority">The priority of the attributed member. Higher numbers are prioritized, lower numbers are deprioritized. 0 is the default if no attribute is present.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute.Priority">
            <summary>
            The priority of the member.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.ParamCollectionAttribute">
            <summary>
            Indicates that a method will allow a variable number of arguments in its invocation.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.RequiredMemberAttribute">
            <summary>
            Specifies that a type has required members or that a member is required.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.RequiresLocationAttribute">
            <summary>
            Reserved for use by a compiler for tracking metadata.
            This attribute should not be used by developers in source code.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.SkipLocalsInitAttribute">
            <summary>
            Used to indicate to the compiler that the <c>.locals init</c> flag should not be set in method headers.
            </summary>
        </member>
        <member name="M:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute"/> class.
            </summary>
        </member>
        <member name="M:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute"/> class with the specified message.
            </summary>
            <param name="message">An optional message associated with this attribute instance.</param>
        </member>
        <member name="P:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute.Message">
            <summary>
            Returns the optional message associated with this attribute instance.
            </summary>
        </member>
        <member name="P:System.Runtime.Versioning.RequiresPreviewFeaturesAttribute.Url">
            <summary>
            Returns the optional URL associated with this attribute instance.
            </summary>
        </member>
    </members>
</doc>
